一、我认为优先级最高的几个雷（建议 P0 / P1）
1）awaitResult + @MainActor = 经典死锁雷

位置：

Sources/SkyBridgeCore/Security/P2PSecurityManager.swift

P2PSecurityManager 整个类是 @MainActor

establishSessionKey 里调用：

let enc = try awaitResult { try await provider.kemEncapsulate(...) }
let ss2 = try awaitResult { try await provider.kemDecapsulate(...) }


awaitResult 定义：

private func awaitResult<T>(_ body: @escaping () async throws -> T) throws -> T {
    let g = DispatchGroup()
    g.enter()
    var result: Result<T, Error>!
    Task { @MainActor in
        do { let v = try await body(); result = .success(v) } catch { result = .failure(error) }
        g.leave()
    }
    g.wait()
    switch result! {
    case .success(let v): return v
    case .failure(let e): throw e
    }
}


问题：

P2PSecurityManager 是 @MainActor，establishSessionKey 也是在 MainActor 上执行。

里面开了一个 Task { @MainActor in ... }，然后当前线程（同一个 MainActor）立刻 g.wait() 阻塞。

MainActor 被 g.wait() 卡住了，新建的 Task { @MainActor ... } 永远没有机会在 MainActor 上跑，g.leave() 永远不会调用，100% 死锁。

只要在真实路径上调用 establishSessionKey，UI 就直接卡死，不是“理论风险”，而是典型死锁模式。

建议修法（方向）：

要么：把 QuantumCryptoManager / PQCProvider 的调用改成彻底 async，establishSessionKey 本身标记为 async throws，上层用 await，别再搞同步封装。

要么：这个同步封装必须在非 MainActor 上做，比如：

把 awaitResult 搬到 nonisolated / 非 @MainActor 的 helper 里；

Task { ... } 不要再标记 @MainActor，让它在后台 executor 跑，然后当前线程阻塞。但这也不优雅。

总体建议：干脆删掉 awaitResult 这一套，PQC 协商全链路改 async，比现在这个“MainActor + DispatchGroup”组合健康太多。

2）SSH 仍然是「接受所有 HostKey」——安全性完全靠天

位置：

Sources/SkyBridgeCore/RemoteConnection/SSHSession.swift

有个委托：

final class AcceptAllHostKeysDelegate: NIOSSHClientServerAuthenticationDelegate {
    func validateHostKey(hostKey: NIOSSHPublicKey, validationCompletePromise: EventLoopPromise<Void>) {
        validationCompletePromise.succeed(())
    }
}


并且在建立连接时多处：

let hostKeyDelegate = AcceptAllHostKeysDelegate()


问题：

这就是字面意义的“任何服务器公钥都信任”。

生产环境相当于完全没有主机身份校验，MITM / DNS 劫持 = 透明成功。

建议：

至少要有一个「开发模式 / Debug 开关」，默认关闭 AcceptAllHostKeysDelegate。

正常模式下走：

本地 known_hosts 风格存储；

或者你自己的「信任设备公钥表」（你已经有 P2P / Supabase 信任体系了，完全可以统一）。

3）AQI 接口里用的是硬编码 demo key

位置：

Sources/SkyBridgeCore/Weather/WeatherService.swift

代码片段：

// OpenWeatherMap
let urlString = "https://api.openweathermap.org/data/2.5/air_pollution?lat=\(latitude)&lon=\(longitude)&appid=demo_key"

// WAQI
let urlString = "https://api.waqi.info/feed/geo:\(latitude);\(longitude)/?token=demo"


问题：

这两个 demo_key / token=demo 在真实环境下基本等于不可用，或者马上 hit rate limit。

而当前 AQI 逻辑是：

OWM；

WAQI；

再 fallback 能见度估算。

只要联网环境正常，这两个请求会稳定失败 + 白白占用网络与日志。
上线前必须：

换成从 APIKeyManagementView / 配置中心读的真实 key；

或在没有 key 的情况下直接跳过外部 API，避免对外乱打 demo endpoint。

4）PQC / HPKE：OQSProvider 的 HPKE 完全未集成

位置：

Sources/SkyBridgeCore/QuantumSecure/PQCProvider.swift

摘关键几行：

func hpkeSeal(...) async throws -> (ciphertext: Data, encapsulatedKey: Data) {
    throw NSError(domain: "PQC", code: -104, userInfo: [NSLocalizedDescriptionKey: "oqs-provider 尚未集成"])
}
func hpkeOpen(...) async throws -> Data {
    throw NSError(domain: "PQC", code: -105, userInfo: [NSLocalizedDescriptionKey: "oqs-provider 尚未集成"])
}


以及：

@available(macOS 14.0, *)
extension OQSProvider: PQCHPKEProvider {
    func senderContext(...) throws -> HPKESenderContext {
        throw NSError(domain: "PQC", code: -903, userInfo: [NSLocalizedDescriptionKey: "HPKE unsupported in OQSProvider"])
    }
    func recipientContext(...) throws -> HPKERecipientContext {
        throw NSError(domain: "PQC", code: -904, userInfo: [NSLocalizedDescriptionKey: "HPKE unsupported in OQSProvider"])
    }
}


问题：

只要哪条路径在 OQS 后端上错误地调用了 HPKE，就是直接抛异常。

好消息是：目前看调用方大多还停留在“示例 / 预留”，真正会话协商更多是 AES-GCM + KEM。

要求：

必须保证所有生产路径在选择 HPKE 时明确区分 backend：

backend == .applePQC 才允许走 HPKE；

liboqs 必须明确“不支持 HPKE”，不要走这条代码。

你已经有 PQCBackend / PQCAlgorithmSuite 之类的枚举，把这层判断做到所有入口之前就行。

二、加密 / 协议层的“半成品”与潜在逻辑坑
5）P2P 会话密钥协商：KEM 使用方式还是“本机演示级”的

位置：

P2PSecurityManager.establishSessionKey(with:publicKey:)

逻辑大概是：

if let provider = PQCProviderFactory.makeProvider() {
    let enc = try awaitResult { try await provider.kemEncapsulate(peerId: deviceId, kemVariant: "ML-KEM-768") }
    let ss2 = try awaitResult { try await provider.kemDecapsulate(peerId: deviceId, encapsulated: enc.encapsulated, kemVariant: "ML-KEM-768") }
    // 然后基于 ss2 / P256 HKDF 派生 sessionKey
}


配套注释：

注意：此处为简化演示，真实场景需通过上层信令交换对端公钥标签

问题：

现在这一套，其实是在同一进程里既封装又解封，更像“自测”，而不是跨设备协商。

真正的流程应该是：

A：拿 B 的公钥 / 标记 → 调 kemEncapsulate → 发送 encapsulated 给 B；

B：基于自己私钥 + 收到的 encapsulated → kemDecapsulate → 得到共享密钥；

双方再各自派生对称密钥。

目前这段代码没有看见消息传递层的参与，看起来是“把 liboqs 当作一个伪随机源”，而不是实际和对端对齐。

建议：

把这段逻辑挪到“真正的 P2P handshake 层”，让 P2PSecurityManager 只提供：

func kemEncapsulate(peerId: String, suite: ...) async throws -> (ss: Data, enc: Data)

func kemDecapsulate(peerId: String, enc: Data, suite: ...) async throws -> Data

上层握手负责把 enc 在两端传过去，不要在一个函数里把封装 + 解封都做掉。

6）Apple PQC 类型仍然是“猜 API 名字”的占位写法

例子：

QuantumCryptoManager.generateHPKEKeyPair()：

@available(macOS 26.0, *)
public static func generateHPKEKeyPair() throws -> (privateKey: XWingMLKEM768X25519.PrivateKey, publicKey: XWingMLKEM768X25519.PublicKey) {
    // 注意：API 可能是 generate() 或 init()，根据实际文档调整
    let privateKey = try XWingMLKEM768X25519.PrivateKey.generate()
    let publicKey = privateKey.publicKey
    return (privateKey, publicKey)
}


以及 UltraStream / ApplePQCProvider 里类似的 HPKE.Sender(... ciphersuite: .XWingMLKEM768X25519_SHA256_AES_GCM_256, ...)。

事实：

这里明确写着“API 可能是 generate() 或 init()”，说明这部分代码本身就是基于未来文档的猜测。

编译能不能过，完全取决于 Apple 最终 API 是否刚好这么设计；现在这就是典型“未来占位”。

建议：

保留结构没问题，但要在代码里明确标记为占位（目前有注释，但你自己未来会忘）。

真正上 Xcode 新 SDK 之后，要做一次通篇对照 Apple 文档：

类型名是否一致；

ciphersuite enum 名是否一致；

integrityCheckedRepresentation 等序列化接口是否存在 / 是否改名。

在那之前，把这些代码当成“只在 macOS 26 + 最新 SDK 下启用的 feature branch”，不要期望它在当前环境跑。

三、功能级 / UX 级的“残缺”和占位

这些不是立刻爆炸，但会导致体验不完整，或者安全性减分。

7）P2P 手动连接：publicKey 为空的占位

位置：

P2PConnectionView.swift：

ManualConnectSheet { host, port, name, type in
    // 构造最小设备信息并发起连接（公钥为空为占位）
    let device = P2PDevice(
        id: UUID().uuidString,
        name: name,
        type: type,
        address: host,
        port: port,
        ...
        pubKeyFingerprint: nil,
        macAddresses: nil
    )
    onConnect(device)
}


问题：

手动添加设备时，完全没有 P-256 公钥 / 指纹，和你前面那套“强身份 / 量子加密信任体系”完全脱节。

如果上层默认把这类设备也当作“信任设备”，那就相当于开了一个无身份验证的后门。

建议：

至少 UI 上要标清楚：“未验证设备 / 手动设备”；安全策略上不允许它享受 full-trust。

更理想的是：手动添加也要求用户贴入一个 fingerprint / 设备 token，让 P2PSecurityManager 可以在第一次连接时校验。

8）Weather / DynamicWallpaper：功能逻辑基本 ok，但模型 / 效果部分仍然简化

好的一面：

WeatherMLPredictor.loadMLModel() 现在是：

if let modelURL = Bundle.main.url(forResource: "WeatherPredictionModel", withExtension: "mlmodelc") {
    self.mlModel = try MLModel(contentsOf: modelURL)
    backend = CoreMLBackend(model: self.mlModel)
} else {
    self.mlModel = nil
    backend = RuleEngineBackend()
}


这已经是我之前建议的“有模型用模型，无模型走规则引擎”，不会再因为假模型崩溃。

DynamicWallpaperManager 初始化里对 MetalFX 也做了 family 检测，旧设备上优雅降级。

残留的小问题：

WeatherMLPredictor 里 createMockMLModel() 还在，是彻底没用到的占位函数，可以考虑删掉，减噪。

WeatherEffectView 里各种 “简化占位符（由 DashboardView 处理完整效果）” 的注释还在，说明视觉效果还没完全对齐最终设计——不算 bug，只是还没完工。

9）UltraStream 的 HPKE 协议是“示例层”

位置：

UltraStream/UltraStream.swift 底部的：

// MARK: - PQC HPKE X-Wing 会话密钥协商（示例层）
// ...
public enum UltraStreamKeyAgreement { ... }


里面说明也写得很清楚，是“演示如何用 CryptoKit HPKE + XWingMLKEM768X25519 生成会话对称密钥”。

现状：

这块现在没真正接到 UltraStream 的生产握手里，只是一个工具 / 示例。

不会直接炸，但也不能当成“已经有了完整会话协商”。

10）杂项占位 / 示例

这些更多是“代码还没完工”的信号，不是炸弹：

QuantumBeam struct 明确写着“占位符实现”；

EnhancedDeviceDiscovery 只是个空壳（startScanning 里没真正扫描逻辑）；

PreferencesView 用的 skybridge.example.com / support@skybridge.example.com 还没换成真实域名；

OQSRAIISample / PQCKeyMigrationTool 就是纯 sample / tool，不会被主流程调用。

四、已经明显改善 / 修掉的点（顺便给你一个 sanity check）

为了避免你怀疑我没看之前那堆：

BGRA 内存生命周期问题

Metal4EnhancedRenderer.renderBGRAFrame 已经统一走 BGRAFrameBuilder.buildPixelBuffer(...)；

BGRAFrameBuilder 的 .safeCopy 是标准 CVPixelBufferCreate + memcpy，.zeroCopy 目前明确抛 zeroCopyNotImplemented；

之前那个 CVPixelBufferCreateWithBytes + Data 绑定异步纹理的悬挂指针问题，已经消失，这是实打实的提升。

TLS Identity 类型检查

TLSSecurityManager.createServerListener 里新增：

if let identity = certificateManager.getIdentity(for: deviceId) {
    if CFGetTypeID(identity) == SecIdentityGetTypeID() {
        let secIdentity = sec_identity_create(identity)
        if let secIdentity = secIdentity {
            sec_protocol_options_set_local_identity(secOptions, secIdentity)
        }
    }
}


这就是我们前面讨论的 S1 增强，已经落地。

WeatherMLPredictor 真实模型 + 规则回退

不再企图构造一个假的 MLModel(contentsOf: Bundle.main.bundleURL)，而是显式 nil + RuleEngine，干净多了。

这些地方我确认过，确实比你之前那版“更安全、更稳”。

总结一句人话

真雷：
P2PSecurityManager.awaitResult 死锁风险、SSH 全信任 HostKey、AQI demo key、OQS HPKE 未集成但接口已暴露 —— 这几个要优先收拾。

半成品：
P2P 会话 KEM 流程（本机自嗨）、Apple PQC/HPKE 的类型 & API 依然是“预测未来文档”的写法 —— 这些等你手里有最新 Xcode / 文档时，一次性对表修正。

无伤占位：
WeatherEffect、QuantumBeam、UltraStreamKeyAgreement 示例层、若干 example 域名——更多是 Roadmap 的提醒，不是炸弹。
