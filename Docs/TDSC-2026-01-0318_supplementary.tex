\documentclass[10pt,journal,compsoc]{IEEEtran}
\usepackage{booktabs}
\usepackage{url}
\usepackage{array}
\usepackage{calc}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage[hidelinks]{hyperref}
\hypersetup{
    pdftitle={},
    pdfauthor={},
    pdfsubject={},
    pdfkeywords={}
}
\usepackage{xr-hyper}
% Allow supplementary to reference main-paper labels when the .aux exists.
\makeatletter
\IfFileExists{IEEE_Paper_SkyBridge_Compass_patched.aux}{\externaldocument{IEEE_Paper_SkyBridge_Compass_patched}}{}
\makeatother

% Submission format: suppress running headers and page numbers.
\makeatletter
\def\ps@headings{%
  \let\@oddhead\@empty
  \let\@evenhead\@empty
  \let\@oddfoot\@empty
  \let\@evenfoot\@empty
}
\def\ps@IEEEtitlepagestyle{%
  \let\@oddhead\@empty
  \let\@evenhead\@empty
  \let\@oddfoot\@empty
  \let\@evenfoot\@empty
}
\makeatother
\pagestyle{headings}

\newcommand{\real}[1]{#1}
\newcommand{\artifacturl}{https://github.com/billlza/Skybridge-Compass}
\newcommand{\artifacturlshort}{https://github.com/billlza/Skybridge-Compass}
\newcommand{\artifacttag}{tdsc-2026-01-0318}
\newcommand{\artifactsha}{805c83a85d22}
\newcommand{\artifactdate}{2026-01-23}
\newcommand{\artifactdateSystemImpact}{2026-01-23}
\newcommand{\artifactzipurl}{\artifacturl/archive/refs/tags/\artifacttag.zip}
\newcommand{\artifactzipsha}{c777f428\allowbreak{}672cec69\allowbreak{}9fcf905c\allowbreak{}2e9902d8\allowbreak{}ce458e8d\allowbreak{}454d852d\allowbreak{}4fe05780\allowbreak{}38d97d2c}
\newcommand{\artifacttarurl}{\artifacturl/archive/refs/tags/\artifacttag.tar.gz}
\newcommand{\artifacttarsha}{0ab8b649\allowbreak{}c937ca53\allowbreak{}2d37764e\allowbreak{}bbdc07b6\allowbreak{}92cfd738\allowbreak{}d649cfea\allowbreak{}d80f87d4\allowbreak{}985f7d61}
\providecommand{\tightlist}{%
	  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

% S1/S2/S3 numbering system
\renewcommand{\thetable}{S\arabic{table}}
\renewcommand{\thefigure}{S\arabic{figure}}

\begin{document}

\title{SkyBridge Compass: Supplementary Materials}
\author{Zi'ang Li, Peng Liu\\Independent Researcher, Tianjin, China\\E-mail: 2403871950@qq.com\\Independent Researcher, Qiqihar, China}
\maketitle

\section*{Supplementary Tables}

This document provides extended data tables referenced in the main paper. All data is derived from the artifact repository CSV files.

\textbf{Correspondence with Main Text:}
\begin{itemize}
\raggedright
\item Table~\ref{tab:supp-latency} (Latency): Referenced in main paper Section~\ref{sec:evaluation}, supports Table~\ref{tab:perf-summary} and Fig.~\ref{fig:handshake-latency}
\item Table~\ref{tab:supp-rtt} (RTT): Referenced in main paper Section~\ref{sec:evaluation}, supports Table~\ref{tab:perf-summary}
\item Table~\ref{tab:supp-message-sizes} (Message Sizes): Referenced in main paper Section~\ref{sec:evaluation}, supports Table~\ref{tab:perf-summary} and Fig.~\ref{fig:message-size-breakdown}
\item Table~\ref{tab:supp-loopback-wire} (Loopback Wire Sizes): Supports Table~\ref{tab:baseline-comparison} (baseline comparison)
\item Tables~\ref{tab:supp-repeatability-latency}--\ref{tab:supp-repeatability-rtt} (Repeatability): Supports Section~\ref{sec:evaluation}. Tables report observed batch count $B$ and (when $B \ge 2$) 95\% confidence intervals across batches; set \texttt{SKYBRIDGE\_BENCH\_BATCHES=3}--\texttt{5} to reproduce multi-batch CIs.
\item Table~\ref{tab:supp-traffic-padding} (Traffic Padding): Supports Section~\ref{sec:evaluation} (traffic analysis mitigation quantization/overhead)
\item Table~\ref{tab:supp-realnet-microstudy} (Real-network micro-study): STUN path + 12~kB-class payload measurements across Wi-Fi / hotspot labels (generated from \texttt{Artifacts/realnet\_*}). (Cross-NAT inbound-reachability depends on ISP/upstream equipment and may be infeasible without administrative control; see note below.)
\end{itemize}

\subsection*{Table~\ref{tab:supp-latency}: Full Handshake Latency Statistics}

\input{supp_tables/s1_latency}

\subsection*{Table~\ref{tab:supp-rtt}: Full RTT Statistics}

\input{supp_tables/s2_rtt}

\subsection*{Table~\ref{tab:supp-message-sizes}: Message Size Breakdown by Field}

\input{supp_tables/s3_message_sizes}

\subsection*{Table~\ref{tab:supp-traffic-padding}: SBP2 Traffic Padding Quantization Summary}

\input{supp_tables/s7_traffic_padding}

\subsection*{Table~\ref{tab:supp-traffic-padding-sensitivity}: SBP2 Bucket-Cap Sensitivity Study}

\input{supp_tables/s8_traffic_padding_sensitivity}

\subsection*{Table~\ref{tab:supp-realnet-microstudy}: Real-Network Micro-Study (External Validity)}

\IfFileExists{supp_tables/s9_realnet_microstudy.tex}{\input{supp_tables/s9_realnet_microstudy}}{\noindent\textit{(Real-network micro-study table not present: run \texttt{Scripts/run\_real\_network\_probe.swift} and \texttt{Scripts/run\_real\_network\_e2e.swift}, then \texttt{python3 Scripts/aggregate\_realnet.py}.)}\par}

\noindent\textit{Note: Cross-NAT direct inbound tests (no overlay/relay) are not universally feasible. In particular, double-NAT topologies (ISP router/modem upstream) and IPv6 inbound filtering can prevent any inbound reachability even when devices have global IPv6 addresses. In such environments, all client samples time out with empty connect-time fields, and we omit those rows from the main table to avoid conflating ``connectivity unavailable'' with protocol performance.}

\textbf{Wire Size Summary:}
\begin{itemize}
\item Classic: $293 + 318 + 2 \times 38 = 687$~B
\item PQC: $6507 + 5419 + 2 \times 38 = 12{,}002$~B
\end{itemize}

\subsection*{Table~\ref{tab:supp-loopback-wire}: Loopback Wire-Size Baselines}

\begin{table}[!t]
\centering
\caption{Loopback wire-size baselines from pcap capture (N=1000). Wire bytes count full packet lengths observed on the loopback interface; TLS/QUIC/DTLS values are cert-dependent.}
\label{tab:supp-loopback-wire}
\begin{tabular}{@{}lrr@{}}
\toprule
Protocol & Wire p50 (B) & Wire p95 (B) \\
\midrule
TLS 1.3 & 8{,}824 & 8{,}948 \\
QUIC & 7{,}830 & 14{,}427 \\
WebRTC DTLS & 3{,}090 & 3{,}162 \\
Noise XX & 2{,}560 & 2{,}672 \\
SkyBridge (classic) & 4{,}874 & 5{,}028 \\
SkyBridge (liboqs) & 37{,}779 & 44{,}609 \\
SkyBridge (CryptoKit) & 19{,}009 & 19{,}257 \\
\bottomrule
\end{tabular}
\end{table}

Values are cert-dependent (localhost certificate). Noise-XX wire size is
pattern-dependent and reflects the XX pattern used in this baseline.
SkyBridge loopback wire sizes include framing and transport overhead;
payload-only sizes are reported in Table~\ref{tab:supp-message-sizes}.

\subsection*{Table~\ref{tab:supp-repeatability-latency}: Repeatability Across Batches (Latency)}

\input{supp_tables/s5_repeatability_latency}

\subsection*{Table~\ref{tab:supp-repeatability-rtt}: Repeatability Across Batches (RTT)}

\noindent\textit{Interpretation note:} CryptoKit PQC RTT exhibits higher \emph{between-batch} variance than Classic/liboqs in our environment (Apple Silicon, macOS 26.x), so its across-batch 95\% CI can be substantially wider even when each batch uses N=1000 iterations. This reflects run-to-run scheduler/load sensitivity rather than an arithmetic error; raw batch values are directly recorded in \texttt{Artifacts/handshake\_rtt\_\artifactdate.csv}.

\input{supp_tables/s6_repeatability_rtt}

\subsection*{Data Sources}

All data is generated from the artifact CSV files:
\begin{itemize}
\raggedright
\item \texttt{Artifacts/\allowbreak handshake\_\allowbreak bench\_\allowbreak \artifactdate.csv} (Tables~\ref{tab:supp-latency}, \ref{tab:supp-repeatability-latency})
\item \texttt{Artifacts/\allowbreak handshake\_\allowbreak rtt\_\allowbreak \artifactdate.csv} (Tables~\ref{tab:supp-rtt}, \ref{tab:supp-repeatability-rtt})
\item \texttt{Artifacts/\allowbreak message\_\allowbreak sizes\_\allowbreak \artifactdate.csv} (Table~\ref{tab:supp-message-sizes})
\item \texttt{Artifacts/\allowbreak traffic\_\allowbreak padding\_\allowbreak \artifactdate.csv} (Table~\ref{tab:supp-traffic-padding})
\item \texttt{Artifacts/\allowbreak traffic\_\allowbreak padding\_\allowbreak sensitivity\_\allowbreak \artifactdate.csv} (Table~\ref{tab:supp-traffic-padding-sensitivity})
\item \texttt{Artifacts/\allowbreak baseline\_\allowbreak summary\_\allowbreak 2026-01-15\_\allowbreak 162127.csv} (Table~\ref{tab:supp-loopback-wire})
\end{itemize}

These files can be regenerated using \texttt{Scripts/\allowbreak run\_\allowbreak paper\_\allowbreak eval.sh} from the artifact repository; \texttt{Scripts/\allowbreak make\_\allowbreak tables.py} uses the main-paper-pinned \texttt{\string\artifactdate} (or an explicit \texttt{ARTIFACT\_DATE}) to avoid accidentally mixing datasets. System-level impact artifacts (\texttt{system\_impact\_\ldots}) are generated by a separate benchmark suite and are pinned consistently in the main paper via \texttt{\string\artifactdateSystemImpact}.

Artifact release:
\begin{itemize}\tightlist
\raggedright
\item URL: \url{\artifacturl}
\item Tag: \texttt{\artifacttag}
\item Commit: \texttt{\artifactsha}
\item Source archive: \href{\artifactzipurl}{\texttt{\artifacttag.zip}} SHA256=\texttt{\artifactzipsha}
\item Source archive: \href{\artifacttarurl}{\texttt{\artifacttag.tar.gz}} SHA256=\texttt{\artifacttarsha}
\end{itemize}

\section*{Supplementary Methods and Details}

\subsection*{Wire Format and Validation Rules}

\textbf{Key Share Semantics:} The \texttt{keyShares{[}{]}.shareBytes}
field has suite-dependent interpretation:
\begin{itemize}\tightlist
\item
  \textbf{DH suites (X25519):} \texttt{shareBytes} = ephemeral public
  key (32 bytes)
\item
  \textbf{KEM suites (ML-KEM-768):} \texttt{shareBytes} = encapsulated
  key / ciphertext (\texttt{enc}, 1088 bytes)
\end{itemize}

This distinction matters: for DH, the Responder uses the Initiator's
public key to compute a shared secret; for KEM, the Initiator
encapsulates to the Responder's long-term KEM public key (obtained
during pairing), and \texttt{shareBytes} carries the resulting
\texttt{enc}. The Responder decapsulates using their private key.

\textbf{Forward Secrecy Note:} This is a static KEM exchange to a
long-term KEM public key, and thus does \emph{not} provide traditional
PFS semantics. If the long-term KEM private key is compromised later, a
passive attacker who recorded ciphertexts may be able to recover past
session keys.

\textbf{Nonce Freshness:} Each party contributes a 32-byte nonce
(\texttt{clientNonce} in A, \texttt{serverNonce} in B). Both are bound
into the KDF info parameter, ensuring symmetric freshness and enabling a
unique session identifier:

\begin{quote}
\small\ttfamily
handshakeId = SHA256(replayTag ||\\
initiatorNonce || responderNonce ||\\
suiteWireIdLE)
\end{quote}

To prevent short-window replay attacks, implementations SHOULD cache
recent \texttt{handshakeId} values (or the
\texttt{(initiatorNonce,\ responderNonce)} pair) and reject duplicates
within a configurable window (default: 5 minutes).

\textbf{Key Share Binding:}
\begin{itemize}\tightlist
\item
  The \texttt{keyShares[]} array contains at most two entries to bound
  message size. Under the two-attempt strategy, each \texttt{MessageA}
  is homogeneous (PQC/hybrid-only or classic-only), so the two entries
  (if present) belong to the same suite group for that attempt.
\item
  Each entry is a \texttt{(suiteId,\ shareBytes)} tuple.
\item
  The Responder MUST select a suite for which the Initiator provided a
  key share; otherwise reject with \texttt{missingKeyShare}.
\item
  This binds negotiation to actual cryptographic material, preventing
  the ``TLS key\_share mismatch'' class of bugs.
\end{itemize}

\textbf{Explicit Key Confirmation (Finished Frames):}
\begin{itemize}\tightlist
\item
  The Responder sends a short \texttt{Finished\_R2I} frame authenticated
  under the newly derived session keys. The Initiator verifies it and
  replies with \texttt{Finished\_I2R}.
\item
  A session is established only after both Finished frames are
  verified, reducing responder-side half-open state under failures.
\item
  Finished frames are fixed-size authenticated messages (38 bytes each:
  4-byte magic, 1-byte version, 1-byte direction, 32-byte HMAC), adding
  negligible wire overhead compared to PQC payloads.
\item
  Finished MACs are computed over the handshake transcript using
  per-direction keys:
  {\raggedright\ttfamily\small\setlength{\parindent}{0pt}
  finishedMAC = HMAC-SHA256(finishedKey, transcriptHash)\\
  finishedKey\_R2I = HKDF(sessionKey,\\
  \ \ info="SkyBridge-FINISHED|R2I|")\\
  finishedKey\_I2R = HKDF(sessionKey,\\
  \ \ info="SkyBridge-FINISHED|I2R|")\par}
\end{itemize}

\textbf{Anti-Downgrade Invariant:}
\begin{itemize}\tightlist
\item
  The Initiator MUST verify that \texttt{selectedSuite} is a member of
  \texttt{supportedSuites[]} it originally sent.
\item
  It MUST also confirm that \texttt{keyShares[]} contains an entry
  for \texttt{selectedSuite}.
\item
  Since \texttt{sigB} commits to \texttt{MessageA} via
  \texttt{transcriptA}, it binds the initiator's proposal.
\item
  Any tampering with the initiator's offered suites or key shares will
  cause \texttt{sigB} verification to fail.
\end{itemize}

\begin{table*}[!t]
\centering
\caption{Message field validation rules.}
\label{tab:supp-message-field-validation}
\begin{tabular}{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Field
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Validation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Failure Action
\end{minipage} \\
\midrule
version & Must equal protocol version (1) & Reject with versionMismatch \\
supportedSuites & Must contain at least one suite supported by local implementation; unknown IDs are ignored for negotiation but still transcript-bound & Reject with suiteNegotiationFailed \\
keyShares & Unique suiteId per entry, max 2 entries, each shareBytes must match its suiteId's expected length & Reject with invalidMessageFormat \\
selectedSuite & Must be in supportedSuites AND have matching keyShare & Reject with missingKeyShare \\
clientNonce/serverNonce & Must be 32 bytes & Reject with invalidMessageFormat \\
sigA/sigB & Must verify against respective identityPubKey & Reject with signatureVerificationFailed \\
\bottomrule
\end{tabular}
\end{table*}

\textbf{Canonical Encoding Rules (V1 Wire Format):}
\begin{itemize}\tightlist
\item
  \texttt{supportedSuites[]}:
  preference order, signed as-is (first = most preferred)
\item
  \texttt{keyShares[]}:
  entries follow the suite preference order; only suites with provided
  shares appear
\item
  All lists use 2-byte little-endian length prefix
\item
  All integers use little-endian encoding
\item
  Canonical encoding is byte-for-byte specified. Implementations MUST
  NOT reserialize with language-native encoders (e.g., JSON,
  PropertyList), as this may introduce non-determinism
\end{itemize}

\emph{Endianness rationale:} V1 wire format uses little-endian to align
with platform conventions (ARM64 native order). The V2 TLV format uses
network byte order (big-endian) for TLV length fields to align with TLV
conventions in IETF protocols. The two formats serve different purposes:
V1 is the on-wire message encoding and is used as transcript input in v1
deployments (byte-for-byte deterministic). V2 TLV is an optional
transcript-hashing format for forward compatibility and is exercised by
regression tests; it is not used on the wire in v1.

\begin{table*}[!t]
\centering
\caption{Encoding scope (V1 vs V2).}
\label{tab:supp-encoding-scope}
\begin{tabular}{@{}llll@{}}
\toprule
Component & Encoding & Length endianness & Used in v1 deployment \\
\midrule
\texttt{MessageA}/\texttt{MessageB} wire bytes & V1 deterministic & little-endian & yes \\
Transcript hash input (v1) & V1 deterministic & little-endian & yes \\
Transcript hash input (v2) & V2 TLV canonical & big-endian & no (experimental) \\
\bottomrule
\end{tabular}
\end{table*}

Note: The 32-byte \texttt{clientNonce}/\texttt{serverNonce} in message
fields are distinct from the 12-byte \texttt{aeadNonce} used internally
by AES-GCM for authenticated encryption.

\subsection*{Suite Identifiers and Wire Format}

A \textbf{suite} defines the handshake tuple
\texttt{(KEM,\ SIG,\ AEAD,\ KDF)} used for the KEM-DEM envelope and
transcript binding. Data-plane AEAD is negotiated separately and is
fixed to AES-256-GCM in v1. Algorithm suite identifiers use a
structured 16-bit wire format enabling forward compatibility:

\begin{table*}[!t]
\centering
\caption{Suite identifier ranges and components.}
\label{tab:supp-suite-identifiers}
\begin{tabular}{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1556}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Range
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Category
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Suite Components
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Examples
\end{minipage} \\
\midrule
0x00xx & Hybrid PQC (preferred) & X-Wing KEM, ML-DSA-65, AES-256-GCM, HKDF-SHA256 & 0x0001 \\
0x01xx & Pure PQC & ML-KEM-768, ML-DSA-65, AES-256-GCM, HKDF-SHA256 & 0x0101 \\
0x10xx & Classic & X25519 DHKEM, Ed25519, AES-256-GCM, HKDF-SHA256 & 0x1001 \\
0xF0xx & Experimental & Reserved for testing & - \\
\bottomrule
\end{tabular}
\end{table*}

Note: X-Wing is a hybrid KEM combining X25519 + ML-KEM-768; it does not
include a signature algorithm. The suite identifier specifies the full
primitive set, with ML-DSA-65 as the preferred signature algorithm when
available. In v1, protocol signatures are bound to the suite group:
ML-DSA-65 for PQC/hybrid suites and Ed25519 for classic suites. Secure
Enclave P-256 ECDSA is used only for optional device proof-of-possession
and is not used for the main protocol signatures (\texttt{sigA}/\texttt{sigB}).

\begin{table*}[!t]
\centering
\caption{Post-quantum coverage by policy and established suite (v1). ``PQC confidentiality'' refers to resistance against store-now-decrypt-later adversaries \emph{while long-term KEM private keys remain uncompromised}; v1 does not claim PFS for KEM-based PQC suites.}
\label{tab:supp-pqc-coverage}
\begin{tabular}{@{}llllccc@{}}
\toprule
Policy & Outcome & KEM / key establishment & Protocol signature (\texttt{sigA}/\texttt{sigB}) & PQ conf. & PQ auth. & PFS \\
\midrule
default & PQC established & ML-KEM-768 (static recipient key) & ML-DSA-65 & yes & yes & no \\
default & classic fallback & X25519 ephemeral DH & Ed25519 & no & no & yes \\
strictPQC & PQC established & ML-KEM-768 (static recipient key) & ML-DSA-65 & yes & yes & no \\
strictPQC & PQC unavailable & -- (handshake fails) & -- & -- & -- & -- \\
\bottomrule
\end{tabular}
\end{table*}

Unknown suite identifiers are parsed as \texttt{unknown(wireId)} rather
than causing parse failures. This allows older clients to gracefully
reject unsupported suites during negotiation.

Transport/MTU considerations: handshake messages are length-prefixed and
carried on reliable control channels (TCP or QUIC streams), so
fragmentation is handled by the transport layer rather than by the
handshake format itself. QUIC datagrams are reserved for latency-critical
media frames; when datagrams are used for other payloads, senders must
respect the maximum datagram size and chunk accordingly.

\subsection*{KEM-DEM Envelope}

The sealed box structure encapsulates KEM-based authenticated encryption
output with explicit DoS protection. Our construction follows the
KEM-DEM (Key Encapsulation Mechanism + Data Encapsulation Mechanism)
paradigm: KEM.Encapsulate() $\rightarrow$ HKDF-SHA256 $\rightarrow$
AES-256-GCM. We call this an ``HPKE-inspired KEM-DEM envelope'' to
distinguish it from RFC 9180 HPKE, which includes additional features
such as multiple modes (Base, PSK, Auth, AuthPSK), context exporters,
and a more complex key schedule.

We model v1 as a constrained HPKE Base-mode instance: the KEM
encapsulation yields a shared secret, HKDF-Extract/Expand derives an
AEAD key/nonce with domain-separated info (role, suite ID, transcript
hash), and AEAD provides confidentiality and ciphertext integrity under
unique nonces. This makes the security dependencies explicit and
isolates deviations from RFC 9180 to the simplified header/nonce/tag
framing.

On Apple 26+ platforms, CryptoKit provides native HPKE with
quantum-secure cipher suites including X-Wing (ML-KEM-768 + X25519).
When available, implementations SHOULD use CryptoKit's HPKE API directly
rather than this compatibility envelope.

\textbf{Security Goals:}
\begin{itemize}\tightlist
\item
  \textbf{PQC suites:} ML-KEM provides IND-CCA2 KEM security (per FIPS
  203).
\item
  \textbf{Classic suites:} X25519 ephemeral-DH encapsulation
  (DHKEM-style); security relies on the X25519/Gap-DH assumption and
  HKDF key separation.
\item
  \textbf{Payload encryption:} INT-CTXT and IND-CPA via AES-256-GCM in v1
  (compat KEM-DEM), and RFC 9180 HPKE AEAD in v2 (e.g.,
  ChaCha20-Poly1305 in our classic provider).
\item
  \textbf{Key separation:} HKDF with context-specific info parameters
  including role binding.
\end{itemize}

\textbf{Not Covered (delegated to RFC 9180 HPKE on Apple 26+):}
\begin{itemize}\tightlist
\item
  Sender authentication modes (Auth, AuthPSK)
\item
  Incremental AEAD for streaming
\end{itemize}

\textbf{Used in our handshake (classic v2):}
\begin{itemize}\tightlist
\item
  HPKE exporter for deriving the per-session shared secret with
  explicit context binding
\end{itemize}

\textbf{Format Versions:}

The implementation supports two sealed box formats:

\textbf{v1 (Compatibility KEM-DEM):} Used when native HPKE is
unavailable. Explicit nonce and tag fields.

Header (17 bytes):
\begin{center}
\small
\begin{tabular}{|c|c|c|c|}
\hline
magic & version & suite & flags \\
\hline
4B & 1B & 2B & 2B \\
\hline
encLen & nonceLen & tagLen & ctLen \\
\hline
2B & 1B & 1B & 4B \\
\hline
\end{tabular}
\end{center}

Body (v1):
\begin{center}
\small
\begin{tabular}{|c|c|c|c|}
\hline
encapsulatedKey & nonce & ciphertext & tag \\
\hline
encLen & 12B & ctLen & 16B \\
\hline
\end{tabular}
\end{center}

\textbf{v2 (Native HPKE):} Used with CryptoKit HPKE. Nonce and tag are
embedded in the AEAD output.

Header (17 bytes):
\begin{center}
\small
\begin{tabular}{|c|c|c|c|}
\hline
magic & version & suite & flags \\
\hline
4B & 1B & 2B & 2B \\
\hline
encLen & nonceLen & tagLen & ctLen \\
\hline
2B & 0 & 0 & 4B \\
\hline
\end{tabular}
\end{center}

Body (v2):
\begin{center}
\small
\begin{tabular}{|c|c|}
\hline
encapsulatedKey & ciphertext (AEAD output) \\
\hline
encLen & ctLen (includes auth tag) \\
\hline
\end{tabular}
\end{center}

\textbf{Version Detection:} Parsers distinguish v1 from v2 by checking
\texttt{nonceLen} and \texttt{tagLen}:
\begin{itemize}\raggedright\tightlist
\item
  v1: \texttt{nonceLen = 12}, \texttt{tagLen = 16}
\item
  v2: \texttt{nonceLen = 0}, \texttt{tagLen = 0} (AEAD details
  encapsulated by library)
\end{itemize}

Length limits enforce DoS protection:
\begin{itemize}\raggedright\tightlist
\item
  \texttt{encLen <= 4096} bytes (sufficient for ML-KEM-768's 1088-byte
  ciphertext)
\item
  v1: \texttt{nonceLen = 12} bytes, \texttt{tagLen = 16} bytes (AES-GCM
  fixed)
\item
  v2: \texttt{nonceLen = 0}, \texttt{tagLen = 0} (embedded in ciphertext)
\item
  \texttt{ctLen <= 64KB} (handshake phase, pre-authentication window)
\item
  \texttt{ctLen <= 256KB} (post-authentication)
\end{itemize}

Parsing uses overflow-safe arithmetic and validates each field before
allocation.

\subsection*{Platform Support Matrix}

\begin{table*}[!t]
\centering
\caption{Platform support matrix.}
\label{tab:supp-platform-support}
\begin{tabular}{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2326}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3256}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2791}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1628}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
PQC Provider
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Algorithms
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notes
\end{minipage} \\
\midrule
macOS 26+ & ApplePQCProvider & ML-KEM-768, ML-KEM-1024\textsuperscript{1}, ML-DSA-65, ML-DSA-87\textsuperscript{1} & Native CryptoKit \\
macOS 14--15 & OQSPQCProvider & ML-KEM-768, ML-DSA-65 & liboqs fallback \\
macOS 14--15 & ClassicProvider & X25519, Ed25519 & If liboqs unavailable \\
iOS 26+ & ApplePQCProvider & ML-KEM-768, ML-KEM-1024\textsuperscript{1}, ML-DSA-65, ML-DSA-87\textsuperscript{1} & Native CryptoKit \\
iOS 17--18 & ClassicProvider & X25519, Ed25519 & liboqs not bundled \\
\bottomrule
\end{tabular}
\end{table*}

\textsuperscript{1} ML-KEM-1024 and ML-DSA-87 are available in CryptoKit
on Apple 26+ but not currently used by our implementation. X-Wing
hybrid KEM (wireId 0x0001) is reserved for future use. Secure Enclave
PQC keys are only available on Apple 26+; earlier versions fall back to
software PQC and P-256 Secure Enclave PoP.

\subsection*{Native PQC Integration}

The \texttt{ApplePQCCryptoProvider} wraps CryptoKit ML-KEM and ML-DSA
APIs, enabling platform-backed PQC suites and HPKE-based encapsulation.
This construction (KEM $\rightarrow$ HKDF $\rightarrow$ AEAD) is
inspired by HPKE but does not implement the full RFC 9180
specification. On Apple 26+ platforms, CryptoKit exposes HPKE cipher
suites including X-Wing (ML-KEM-768 with X25519), enabling a
standards-aligned replacement for our compatibility envelope. This
layer can then be replaced with direct CryptoKit PQ-HPKE calls.

\subsection*{Conditional Compilation Strategy}

The \texttt{HAS\_APPLE\_PQC\_SDK} flag gates \textbf{all} PQC type
references. Importantly, \texttt{@available} only controls
\emph{runtime} availability; it does not prevent \emph{compile-time}
failures when the SDK lacks the PQC symbols.

For reproducible builds across toolchains, we intentionally \textbf{do
not} enable \texttt{HAS\_APPLE\_PQC\_SDK} by default in SwiftPM (because
\texttt{.when(platforms:\ {[}.macOS{]})} does not reflect SDK
availability and will break older Xcode builds). Instead, projects
inject the flag from build settings \textbf{only} when compiling with
the Apple 26 SDK (Xcode 26+):
\texttt{OTHER\_SWIFT\_FLAGS = \allowbreak \$(inherited) \allowbreak -DHAS\_APPLE\_PQC\_SDK}

This keeps the codebase buildable on older Xcode versions (classic
provider path), while enabling native CryptoKit PQC providers only when
the correct SDK is present.

\subsection*{Security Event Emission}

All cryptographic decisions emit structured events. The
\texttt{SecurityEventEmitter} actor implements backpressure with
per-subscriber queues and meta-event rate limiting to prevent recursive
overflow.

\subsection*{Secure Enclave Integration}

For hardware-backed signing, the \texttt{SigningCallback} protocol
enables Secure Enclave integration. The \texttt{HandshakeDriver}
prioritizes callback-based signing over raw key material, ensuring
private keys never leave the Secure Enclave.

\textbf{Availability and fallback.} Secure Enclave--backed ML-DSA/ML-KEM
keys are only available on macOS 26+ via CryptoKit. On macOS 14--15, PQC
operations fall back to liboqs (software), and Secure Enclave is used
only for P-256 ECDSA proof-of-possession keys. When Secure Enclave PQC
is used, the implementation relies on CryptoKit key types
\texttt{SecureEnclave.MLDSA*} and \texttt{SecureEnclave.MLKEM*}, which are
gated by the macOS 26+ SDK and runtime availability checks.

\subsection*{Signing Key Hierarchy}

The system supports two complementary signing mechanisms:

\begin{enumerate}
\item \raggedright
  \textbf{CryptoProvider signing (Protocol Signature):}\\
  Uses the active suite's signature algorithm (Ed25519 for classic, ML-DSA-65 for PQC)
  for protocol-level identity verification. Keys are managed by the
  CryptoProvider and stored in software. This is the primary signature
  used in \texttt{sigA}/\texttt{sigB} fields of handshake messages.
\item \raggedright
  \textbf{Secure Enclave signing (Device PoP):}\\
  Uses EC P-256 with ECDSA
  via \texttt{Secure\allowbreak Enclave\allowbreak Signing\allowbreak Callback} to prove the peer controls a
  key stored in Secure Enclave. Private keys never leave the Secure
  Enclave hardware. Note: This provides proof-of-possession of a
  hardware-backed key, not full device attestation (Apple does not
  expose a general-purpose attestation API with certificate chains at
  the application layer). The security value derives from the key being
  pinned during initial pairing.
\end{enumerate}

\textbf{Implementation Note.} \texttt{Device\allowbreak Identity\allowbreak Key\allowbreak Manager}
creates P-256 keys in Secure Enclave (when available) for hardware-backed
device identity. These keys are used for the optional
\texttt{seSigA}/\texttt{seSigB} proof-of-possession signatures, NOT for
the primary protocol signatures (\texttt{sigA}/\texttt{sigB}). The
primary protocol signatures use Ed25519 (classic) or ML-DSA-65 (PQC)
keys generated by the CryptoProvider.

The \texttt{Fallback\allowbreak Signing\allowbreak Callback} provides automatic fallback from
Secure Enclave to CryptoProvider when hardware signing is unavailable
(e.g., on devices without Secure Enclave or when the key has not been
provisioned).

\textbf{Use Case Separation:}
\begin{itemize}\tightlist
\item
  CryptoProvider (Ed25519/ML-DSA): Primary protocol signatures,
  cross-platform interoperability, suite-negotiated
\item
  Secure Enclave (P-256 ECDSA): Optional hardware-backed
  proof-of-possession, proving control of a non-exportable key
\end{itemize}

Both mechanisms can coexist in a single handshake: CryptoProvider for
primary protocol signatures (\texttt{sigA}/\texttt{sigB}), Secure
Enclave for optional hardware-backed proof-of-possession
(\texttt{seSigA}/\texttt{seSigB}).

\textbf{Signature Verification Rules:}
\begin{itemize}\tightlist
\item
  Primary signatures (\texttt{sigA}/\texttt{sigB}) are mandatory and must
  verify against the peer's \texttt{identityPubKey}.
\item
  For paired peers, \texttt{identityPubKey} must match the pinned value
  from initial pairing.
\item
  Optional SE signatures (\texttt{seSigA}/\texttt{seSigB}) elevate trust
  when present and valid.
\item
  Verification order: primary signature, identity pinning, optional SE
  signature.
\end{itemize}

\subsection*{Pre-Negotiation Signature Selection and Two-Attempt Strategy}

A fundamental challenge in our protocol is the ``chicken-and-egg''
problem: \texttt{sigA} must be generated \emph{before} suite negotiation
completes, yet the signature algorithm should be consistent with the
negotiated suite. We resolve this through pre-negotiation signature
selection and a two-attempt strategy.

\textbf{Pre-Negotiation Signature Selection:}
The signature algorithm for \texttt{sigA} is determined by the
\texttt{offeredSuites} in MessageA, not by the final
\texttt{selectedSuite}. The \texttt{Pre\allowbreak Negotiation\allowbreak Signature\allowbreak Selector}
builds offered suites based on the attempt strategy and selects the
appropriate signature algorithm (ML-DSA-65 for PQC suites, Ed25519 for
classic).

\textbf{Homogeneity Invariant:} Each attempt's \texttt{offeredSuites} must
be homogeneous with respect to \texttt{sigAAlgorithm}: ML-DSA-65
requires all PQC suites; Ed25519 requires all classic suites. This
invariant is enforced at compile-time through the type system and at
runtime through \texttt{HandshakeDriver} initialization validation.

\textbf{Two-Attempt Strategy:}
To support interoperability between PQC-capable and classic-only
devices, we employ a two-attempt strategy: (1) PQC attempt with ML-DSA-65
signatures, then (2) classic fallback with Ed25519 if the PQC attempt
fails due to provider unavailability or suite negotiation failure. In
particular, for a classic-only peer without a pinned PQC KEM public key
from pairing, the PQC attempt fails locally during \texttt{MessageA}
construction (no key shares $\rightarrow$ \texttt{suiteNegotiationFailed}),
so fallback is immediate and is not driven by network timeout.

\textbf{Fallback Security:}
Not all failures trigger fallback.

\textbf{Allowed:}
\begin{itemize}\tightlist
\item \texttt{pqcProvider\allowbreak Unavailable}
\item \texttt{suiteNot\allowbreak Supported}
\item \texttt{suite\allowbreak Negotiation\allowbreak Failed}
\end{itemize}

\textbf{Blocked:}
\begin{itemize}\tightlist
\item \texttt{timeout}
\item \texttt{signature\allowbreak Verification\allowbreak Failed}
\item \texttt{identity\allowbreak Mismatch}
\item \texttt{replay\allowbreak Detected}
\end{itemize}

Timeout-based fallback is explicitly blocked to prevent attackers from
forcing downgrade through packet dropping. Per-peer fallback is
rate-limited (default 5-minute cooldown) to prevent rapid downgrade
cycling.

\subsection*{ML-DSA Key Sizes}

\begin{table}[!t]
\centering
\caption{ML-DSA-65 Key Sizes (FIPS 204 Compliance).}
\label{tab:supp-ml-dsa-key-sizes}
\begin{tabular}{@{}llll@{}}
\toprule
Component & Expected & Measured & Status \\
\midrule
Public Key & 1952 B & 1952 B & OK \\
Secret Key & 4032 B & 4032 B & OK \\
Signature & 3309 B & 3309 B & OK \\
\bottomrule
\end{tabular}
\end{table}

\subsection*{Key Size Reference}

\begin{table*}[!t]
\centering
\caption{Key size reference.}
\label{tab:supp-key-size-reference}
\begin{tabular}{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1294}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1412}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2588}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2353}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Algorithm
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Public Key
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Private Key (Apple)\textsuperscript{1}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Private Key (FIPS)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Ciphertext/Signature
\end{minipage} \\
\midrule
ML-KEM-768 & 1184 B & 96 B & 2400 B & 1088 B \\
ML-KEM-1024 & 1568 B & 128 B\textsuperscript{2} & 3168 B & 1568 B \\
ML-DSA-65 & 1952 B & 64 B & 4032 B & 3309 B \\
ML-DSA-87 & 2592 B & 96 B\textsuperscript{2} & 4896 B & 4627 B \\
X25519 & 32 B & 32 B & - & 32 B \\
Ed25519 & 32 B & 32 B & - & 64 B \\
\bottomrule
\end{tabular}
\end{table*}

\textsuperscript{1} Apple CryptoKit uses a seed-based compact format for
private key serialization
(\texttt{integrityChecked\allowbreak Representation}). This is more
storage-efficient than the FIPS 203/204 expanded format. Public keys use
\texttt{rawRepresentation} which matches FIPS standard sizes.
Measurements performed on macOS 26.0 (Tahoe) SDK.

\textsuperscript{2} Not measured directly; projected from the seed-based
pattern observed in ML-KEM-768/ML-DSA-65 (ratio of FIPS expanded size to
Apple compact size). These algorithms are available in CryptoKit but not
exercised by our current benchmark suite.

\subsection*{Security Event Types}

\begin{table*}[!t]
\centering
\caption{Security event types.}
\label{tab:supp-security-event-types}
\begin{tabular}{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3871}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3226}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2903}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Event Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Severity
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Trigger
\end{minipage} \\
\midrule
\texttt{cryptoProviderSelected} & info/warning & Provider factory selection \\
\texttt{cryptoDowngrade} & warning & PQC to classic fallback \\
\texttt{handshakeFailed} & warning & Any handshake failure \\
\texttt{signatureVerificationFailed} & high & Invalid peer protoSignature \\
\texttt{secureEnclaveVerificationFailed} & warning & Invalid secureEnclaveSignature \\
\texttt{identityMismatch} & high & identityPubKey does not match pinned key \\
\texttt{contextZeroized} & info & Sensitive material cleared \\
\texttt{suiteNegotiationFailed} & warning & No common suite found \\
\texttt{unexpectedStateTransition} & high & Actor reentrancy detected \\
\bottomrule
\end{tabular}
\end{table*}

\subsection*{X-Wing Wire Size (Measured)}

X-Wing is a hybrid KEM combining X25519 + ML-KEM-768. In our v1
handshake, the initiator carries only a KEM ciphertext in MessageA;
thus X-Wing increases the MessageA keyshare from 1088~B (ML-KEM-768) to
1120~B (X25519~32~B + ML-KEM-768~1088~B), while MessageB remains
keyshare-free. We measure X-Wing directly via the native CryptoKit
provider (wireId 0x0001) and report per-field sizes in Supplementary
Table~\ref{tab:supp-message-sizes} (\texttt{MessageA.XWing}/\texttt{MessageB.XWing}). The measured
total handshake size (MessageA + MessageB + 2$\times$Finished) is
\textbf{12,195~B}.

\subsection*{Reproducibility}

\textbf{Test Commands.}
One-shot evaluation:
\texttt{Scripts/\allowbreak run\_\allowbreak paper\_\allowbreak eval.sh}.
Individual suites:
\texttt{swift test --filter TestName}.
Representative suite names:
\begin{itemize}\tightlist
\item \texttt{HandshakeBenchmarkTests}
\item \texttt{HandshakeFaultInjectionBenchTests}
\item \texttt{PolicyDowngradeBenchTests}
\item \texttt{MessageSizeSnapshotTests}
\end{itemize}
All CSV outputs are date-stamped under \texttt{Artifacts/}. To prevent mixing datasets across runs, set a fixed date suffix:
\texttt{ARTIFACT\_DATE=YYYY-MM-DD} (or \texttt{SKYBRIDGE\_ARTIFACT\_DATE}).

\textbf{Repeatability (Multi-batch).}
Repeatability tables report observed batch count $B$ and (when $B \ge 2$) mean $\pm$ 95\% confidence intervals across independent batches.
To reproduce multi-batch CIs, rerun with process restarts:
\texttt{ARTIFACT\_DATE=YYYY-MM-DD SKYBRIDGE\_BENCH\_BATCHES=3--5 bash Scripts/run\_paper\_eval.sh}.

\textbf{Real-network micro-study (External validity).}
We provide two lightweight scripts:
(i) \texttt{Scripts/run\_real\_network\_probe.swift} (STUN RTT + conservative NAT classification),
and (ii) \texttt{Scripts/run\_real\_network\_e2e.swift} (TCP connect + first-byte + completion timing for a 12~kB-class payload).
Pin filenames with \texttt{ARTIFACT\_DATE=YYYY-MM-DD}, run them across labels (same Wi-Fi / cross-NAT / hotspot), then aggregate into a Supplementary table via:
\texttt{python3 Scripts/aggregate\_realnet.py}.

\textbf{Note on inbound reachability.}
Some home networks do not provide an inbound-reachable IPv4 address (e.g., double NAT behind an ISP router, CGNAT, DS-Lite, or WAN IPv4 shown as \texttt{0.0.0.0}). In these cases, IPv4 port-forwarding experiments will fail (client samples report \texttt{timeout} with empty \texttt{connect\_ms}). For a true cross-NAT condition without modifying upstream equipment, prefer IPv6 direct connectivity (when available) with an explicit IPv6 firewall allow-rule for TCP \texttt{44444}. If only an overlay/relay path is feasible, label the condition accordingly (e.g., \texttt{cross\_nat\_via\_relay}) and interpret results as overlay-mediated connectivity rather than raw Internet inbound reachability.

\subsection*{Regression Testing}

Transcript integrity uses V1 (deterministic) and V2 (TLV canonical)
encoding formats, validated with 14 test cases (100\% pass rate). TLV
encoding uses 1-byte tags, 4-byte big-endian length fields, and
variable-length values. The complete regression matrix validates
Requirements 12.1--12.6; all 15 regression tests pass, and all 3
compile-fail harness tests correctly produce compile errors.

\textbf{Key Properties:}
(1) P-256 cannot be used as a protocol signature algorithm (compile-time enforced);
(2) PQC attempts use only PQC suites, classic attempts use only classic suites;
(3) Only PQC-unavailability errors trigger fallback;
(4) Legacy P-256 requires authenticated channel or existing TrustRecord;
(5) All fallback and legacy acceptance events include full audit context.

\subsection*{Artifact Map}

Table~\ref{tab:artifact-map} maps implementation components to source
files in the artifact repository (\href{\artifacturl}{\artifacturlshort},
tag=\texttt{\artifacttag}).

\begin{table}[!t]
\centering
\caption{Implementation artifact map.}
\label{tab:artifact-map}
\begin{tabular}{@{}>{\raggedright\arraybackslash}p{0.35\columnwidth}>{\raggedright\arraybackslash\footnotesize}p{0.58\columnwidth}@{}}
\toprule
Component & File (Lines) \\
\midrule
Provider Protocol & \mbox{\texttt{CryptoProviderProtocol.swift}} (L24--110) \\
Handshake Types & \mbox{\texttt{HandshakeTypes.swift}} (L270--289) \\
Provider Factory & \mbox{\texttt{CryptoProviderFactory.swift}} (L18--139) \\
Handshake Driver & \mbox{\texttt{HandshakeDriver.swift}} (L88--166, L992--1012) \\
Handshake Context & \mbox{\texttt{HandshakeContext.swift}} (L27--100, L848--900) \\
Secure Bytes & \mbox{\texttt{SecureBytes.swift}} (L18--99) \\
Message Signatures & \mbox{\texttt{HandshakeMessages.swift}} (L555--567, L797--818) \\
Apple PQC Provider & \mbox{\texttt{ApplePQCProvider.swift}} (L22--120) \\
Security Events & \mbox{\texttt{SecurityEventEmitter.swift}} (L21--140) \\
SE Signing & {\scriptsize\texttt{SecureEnclaveSigningCallback.swift}} (L40--94) \\
Signature Selector & {\tiny\texttt{PreNegotiationSignatureSelector.swift}} (L69--96) \\
\bottomrule
\end{tabular}
\end{table}

\clearpage
\input{supp_appendix_numbers_ledger}

\end{document}
