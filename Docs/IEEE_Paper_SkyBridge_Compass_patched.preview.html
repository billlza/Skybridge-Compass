<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>IEEE_Paper_SkyBridge_Compass_patched</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    /* IEEE Computer Society journal-like layout overrides */
    :root {
      --page-width: 7.16in;
      --page-margin: 0.75in;
      --column-gap: 0.25in;
      --body-font: "Times New Roman", Times, serif;
    }
    html {
      background-color: #ffffff;
      color: #000000;
    }
    body {
      max-width: var(--page-width);
      margin: 0 auto;
      padding: var(--page-margin);
      font-family: var(--body-font);
      font-size: 10pt;
      line-height: 1.1;
      text-align: justify;
      column-count: 2;
      column-gap: var(--column-gap);
      hyphens: auto;
    }
    .front-matter {
      column-span: all;
      text-align: center;
      margin-bottom: 0.18in;
    }
    .front-matter h1 {
      font-size: 17pt;
      font-weight: bold;
      margin: 0 0 0.12in 0;
      line-height: 1.15;
    }
    .front-matter p {
      text-align: justify;
      font-size: 9pt;
      margin: 0.06in 0;
      line-height: 1.1;
    }
    .front-matter p strong {
      font-weight: bold;
    }
    hr {
      display: none;
    }
    h2 {
      font-size: 10pt;
      font-weight: bold;
      text-transform: uppercase;
      margin-top: 0.16in;
      margin-bottom: 0.06in;
      text-align: left;
    }
    h3 {
      font-size: 10pt;
      font-style: italic;
      font-weight: normal;
      margin-top: 0.12in;
      margin-bottom: 0.04in;
      text-align: left;
    }
    p {
      margin: 0.08in 0;
    }
    ol, ul {
      margin: 0.06in 0 0.06in 0.16in;
      padding-left: 0.16in;
    }
    table {
      font-size: 9pt;
    }
    img {
      display: block;
      margin: 0.08in auto;
    }
    @media screen and (max-width: 900px) {
      body {
        column-count: 1;
        padding: 24px;
        font-size: 10pt;
      }
      .front-matter {
        text-align: left;
      }
    }
    @page {
      size: letter;
      margin: var(--page-margin);
    }
  </style>
</head>
<body>
<div class="front-matter">
<h1
id="skybridge-compass-a-crypto-agile-peer-to-peer-remote-desktop-and-file-transfer-system-with-post-quantum-readiness-on-apple-platforms">SkyBridge
Compass: A Crypto-Agile Peer-to-Peer Remote Desktop and File Transfer
System with Post-Quantum Readiness on Apple Platforms</h1>
<p><strong>Abstract—</strong> Peer-to-peer remote desktop and file
transfer systems increasingly operate across heterogeneous devices,
untrusted networks, and long lifecycles in which cryptographic
assumptions may expire faster than products. Yet “post-quantum
readiness” is often treated as a one-off algorithm swap rather than a
migration problem with downgrade resistance, auditability, and
reproducibility requirements. This paper presents SkyBridge Compass, a
crypto-agile P2P system that explicitly separates (i) negotiated
cryptographic suites, (ii) platform-specific provider backends, and
(iii) a policy layer that governs when (and whether) classic fallback is
permissible. We introduce an actor-isolated handshake state machine with
deterministic failure semantics and structured security-event emission,
enabling end-to-end audit trails for downgrade, identity mismatch, and
signature verification failures. We evaluate three configurations on
macOS 26.x: classic (X25519 + Ed25519), PQC via liboqs (ML-KEM-768 +
ML-DSA-65), and PQC via native CryptoKit (ML-KEM-768 + ML-DSA-65).
End-to-end handshake completion latency (including event emission
overhead) is 1.81 ms (p95 2.09 ms) for classic, 6.32 ms (p95 8.15 ms)
for liboqs PQC, and 11.02 ms (p95 16.15 ms) for CryptoKit PQC over
N=1000 iterations. The wire-format size grows from 819 B (classic) to
12,155 B (PQC), and we provide a conservative projection for a hybrid
X-Wing-style exchange of approximately 12.4 KB. Beyond performance, we
validate security-centric properties under fault injection and downgrade
workloads, and we provide scripts and tests that reproduce all primary
figures and tables from released artifacts.</p>
<p><strong>Index Terms—</strong> post-quantum cryptography, crypto
agility, downgrade resistance, secure handshake, peer-to-peer systems,
remote desktop, Apple platforms, auditability, reproducibility.</p>
</div>
<hr />
<h2 id="i.-introduction">I. INTRODUCTION</h2>
<p>Peer-to-peer (P2P) remote desktop and file transfer systems must
establish secure sessions under adversarial network conditions, device
churn, and multi-year lifecycles. These systems face a practical
tension: users demand “it just works” pairing across heterogeneous
stacks, while defenders require that cryptographic negotiation remains
robust against downgrade and implementation-level failure modes.
Post-quantum cryptography (PQC) increases this tension. Larger messages,
higher computational cost, and uneven platform support make fallback
tempting—yet fallback is exactly where silent downgrade and unverifiable
behavior tend to hide.</p>
<p>Existing secure-channel designs and frameworks provide mature
cryptographic building blocks, but they do not, by default, solve the
migration problem an implementer actually faces: (i) selecting among
classic/PQC/hybrid suites across platform strata, (ii) guaranteeing that
policy (e.g., “require PQC”) is enforced at the entry points where
callers cannot accidentally violate it, (iii) ensuring deterministic
failure semantics under timeouts, reorder/duplication, and malformed
inputs, and (iv) emitting security-relevant telemetry that can be
audited without turning the system into a logging minefield. In
practice, many systems either hard-code a single suite, or allow
“compatibility” to creep into negotiation in ways that are hard to
reason about and harder to verify.</p>
<p>This paper addresses these gaps with SkyBridge Compass, a
crypto-agile P2P system designed for explicit PQC migration and
auditability on Apple platforms. The core idea is to treat crypto
agility as a layered contract: negotiated suites define the protocol
surface; provider backends implement suites using platform-native or
portable cryptography; and a policy layer governs fallback and produces
structured evidence when (and only when) downgrade occurs. We complement
this design with an actor-isolated handshake driver that enforces
one-shot completion, timeouts, and sensitive-material zeroization,
yielding deterministic outcomes even under adverse transport
behaviors.</p>
<h3 id="a.-contributions">A. Contributions</h3>
<p>Contributions (reviewer-facing, evidence-backed):</p>
<ol type="1">
<li><p>We turn PQC migration from a narrative into an enforceable
contract by making downgrade and legacy-compatibility decisions
explicit, testable, and auditable rather than implicit “best-effort”
fallback. (Fig. 7; Table XIII; PolicyDowngradeBenchTests,
LegacyFallbackPreconditionTests)</p></li>
<li><p>We design a crypto-agile P2P handshake that cleanly separates
suite negotiation, transcript binding, and protocol-signature keys,
preventing “suite says PQC but keys stay classical” class of integration
bugs. (Fig. 2; Table XIII; ProtocolSignatureRegressionTests,
TranscriptIntegrityPropertyTests)</p></li>
<li><p>We provide migration safety with measurable coverage by
enumerating legacy/PQC strata and validating acceptance/rejection
boundaries under fault injection instead of relying on informal
compatibility claims. (Table VIII; Table V;
HandshakeFaultInjectionBenchTests)</p></li>
<li><p>We harden correctness under concurrency by an actor-isolated
state machine with idempotent transitions and bounded retries,
eliminating double-resume and state desynchronization failure modes.
(Fig. 3; Table XIII; HandshakeDriverTests)</p></li>
<li><p>We make evaluation reproducible by shipping a benchmark harness
that reports distributional statistics (p50/p95/p99) over large-N runs
and links each metric back to a concrete failure taxonomy. (Fig. 6;
Table I–II; HandshakeBenchmarkTests, MessageSizeSnapshotTests)</p></li>
</ol>
<h3 id="b.-paper-organization">B. Paper Organization</h3>
<p>Section II reviews related work on P2P pairing, negotiation, and PQC
migration. Section III details system architecture and protocol design.
Section IV presents the handshake state machine. Section V presents the
security model and guarantees. Section VI describes implementation
details and platform instantiation. Section VII outlines evaluation
methodology and metrics. Section VIII discusses limitations and future
work, and Section IX concludes.</p>
<hr />
<h2 id="ii.-related-work">II. RELATED WORK</h2>
<h3 id="a.-peer-to-peer-device-pairing">A. Peer-to-Peer Device
Pairing</h3>
<p>Device pairing protocols have evolved from simple PIN-based schemes
to sophisticated cryptographic handshakes. Bluetooth Secure Simple
Pairing (SSP) [2] introduced numeric comparison and passkey entry modes,
but remains vulnerable to man-in-the-middle attacks during the initial
exchange. Apple’s Continuity protocols leverage iCloud identity for
cross-device authentication [3], but require cloud connectivity and
Apple ID enrollment.</p>
<p>PAKE (Password-Authenticated Key Exchange) protocols, particularly
SPAKE2+ [4], enable secure pairing using low-entropy secrets without
exposing them to offline dictionary attacks. PAKE-based pairing is
considered as an alternative to our current PIN-comparison approach for
the initial pairing ceremony; however, the pairing phase is out of scope
of this paper’s session handshake protocol. Our system uses visual PIN
comparison during initial pairing while supporting hardware-backed key
storage through Secure Enclave for subsequent sessions.</p>
<h3 id="b.-cryptographic-agility-and-negotiation">B. Cryptographic
Agility and Negotiation</h3>
<p>The concept of cryptographic agility—designing systems to accommodate
algorithm changes without architectural overhaul—has gained prominence
as cryptographic standards evolve [5]. TLS 1.3 and QUIC exemplify suite
negotiation and downgrade defenses by binding the selected parameters
into signed transcripts or transport parameters [6], [18]. However,
agility introduces complexity: systems must handle negotiation failures,
prevent downgrade attacks, and maintain backward compatibility across
heterogeneous peers.</p>
<p>Barker and Roginsky [7] provide NIST guidelines for transitioning to
post-quantum algorithms, emphasizing hybrid approaches that combine
classical and quantum-resistant primitives. Our CryptoProvider
architecture directly implements these recommendations through its
tiered selection mechanism.</p>
<h3 id="c.-handshake-frameworks-and-noise-style-patterns">C. Handshake
Frameworks and Noise-Style Patterns</h3>
<p>Noise provides a compact framework for describing authenticated key
exchange patterns with explicit transcript binding and identity key
usage [19]. While SkyBridge Compass does not implement Noise directly,
our MessageA/MessageB/Finished exchange mirrors the same security goals
(authenticated key agreement with transcript coverage) and explicitly
encodes policy for auditability. This helps position the protocol in a
language familiar to the cryptography community without constraining the
implementation to a fixed pattern family.</p>
<h3 id="d.-post-quantum-cryptography-deployment">D. Post-Quantum
Cryptography Deployment</h3>
<p>NIST’s PQC standardization process culminated in the selection of
CRYSTALS-Kyber (now ML-KEM) for key encapsulation and CRYSTALS-Dilithium
(now ML-DSA) for digital signatures [8]. Early deployment experiences
from Signal [9] and Cloudflare [10] highlight challenges in key size
management and performance optimization.</p>
<p>Apple’s announcement of PQC support in CryptoKit for macOS 26/iOS 26
represents a significant milestone for native platform integration. We
treat Apple platforms as a deployable instance of a platform-agnostic
design, emphasizing policy-driven migration rather than a
platform-specific protocol.</p>
<h3 id="e.-secure-state-machine-design">E. Secure State Machine
Design</h3>
<p>State machine vulnerabilities have been a persistent source of
security bugs in protocol implementations [11]. Actor-based concurrency
models, as implemented in Swift’s actor system [12], provide
compile-time guarantees against data races. We extend this model with
explicit timeout handling and zeroization semantics to address the
unique requirements of cryptographic handshakes.</p>
<hr />
<h2 id="iii.-system-architecture">III. SYSTEM ARCHITECTURE</h2>
<h3 id="a.-overview">A. Overview</h3>
<p>SkyBridge Compass implements a layered architecture separating
concerns across four primary domains: discovery, cryptographic
operations, handshake management, and session transport. Fig. 1
illustrates the high-level component relationships and trust
boundaries.</p>
<h3 id="a.1-threat-model">A.1 Threat Model</h3>
<p>We model an active network attacker in the Dolev-Yao style with the
following <strong>capability set</strong>:</p>
<p><strong>Network Capabilities (Attacker-Controlled):</strong> -
<strong>Drop / delay / reorder / duplicate</strong> packets on the
discovery channel - <strong>Modify / inject</strong> arbitrary bytes in
MessageA/MessageB/Finished frames - <strong>Replay</strong> prior
handshake messages across sessions - <strong>Spoof capability or policy
claims</strong> to induce weaker negotiation - <strong>Force negotiation
failure</strong> by corrupting suites, key shares, or signatures</p>
<p><strong>Defense Mapping (Protocol + Policy):</strong> -
<strong>Transcript binding:</strong> <code>sigB</code> covers MessageA
and the chosen suite, so modifications to
<code>supportedSuites[]</code>, <code>keyShares[]</code>, or
<code>policy</code> fail verification. - <strong>Negotiation
integrity:</strong> Responder MUST select a suite that Initiator offered
and for which a key share exists; otherwise reject
<code>missingKeyShare</code>. - <strong>Replay control:</strong>
<code>handshakeId</code> is derived from nonces and cached to reject
duplicates within a window. - <strong>Downgrade resistance:</strong>
timeout-triggered fallback is disallowed; only whitelisted errors may
fallback under default policy; strictPQC forbids all fallback. -
<strong>Rate limiting:</strong> per-peer fallback cooldown prevents
rapid downgrade cycling. - <strong>Legacy gating:</strong> legacy P-256
acceptance requires an authenticated channel or an existing trust
record.</p>
<p><strong>Trust Assumptions:</strong> 1. The initial pairing ceremony
occurs over a trusted out-of-band channel (e.g., visual PIN comparison
on both device screens) 2. The device Keychain provides integrity
guarantees for stored identity keys 3. The Secure Enclave (when
available) provides hardware-backed key isolation that resists
software-level extraction 4. Users can visually verify device identity
during pairing (no blind trust)</p>
<p><strong>Out of Scope:</strong> - Side-channel attacks on
cryptographic implementations - Physical attacks on Secure Enclave
hardware - Compromise of the operating system kernel - Social
engineering attacks on users</p>
<h3 id="a.2-protocol-message-flow">A.2 Protocol Message Flow</h3>
<p>Fig. 2 illustrates the handshake message sequence and transcript
coverage.</p>
<figure>
<img src="figures/fig_handshake_sequence.png"
alt="Fig. 2. Handshake sequence with transcript coverage and policy visibility." />
<figcaption aria-hidden="true">Fig. 2. Handshake sequence with
transcript coverage and policy visibility.</figcaption>
</figure>
<p><strong>Key Share Semantics:</strong> The
<code>keyShares[].shareBytes</code> field has suite-dependent
interpretation: - <strong>DH suites (X25519):</strong>
<code>shareBytes</code> = ephemeral public key (32 bytes) - <strong>KEM
suites (ML-KEM-768):</strong> <code>shareBytes</code> = encapsulated key
/ ciphertext (<code>enc</code>, 1088 bytes)</p>
<p>This distinction matters: for DH, the Responder uses the Initiator’s
public key to compute a shared secret; for KEM, the Initiator has
already encapsulated to the Responder’s long-term KEM public key
(obtained during pairing), and <code>shareBytes</code> carries the
resulting <code>enc</code>. The Responder decapsulates using their
private key.</p>
<p><strong>Nonce Freshness:</strong> Each party contributes a 32-byte
nonce (<code>clientNonce</code> in A, <code>serverNonce</code> in B).
Both are bound into the KDF info parameter, ensuring symmetric freshness
and enabling a unique session identifier:</p>
<pre><code>handshakeId = SHA256(replayTag || initiatorNonce || responderNonce || suiteWireIdLE)</code></pre>
<p>To prevent short-window replay attacks, implementations SHOULD cache
recent <code>handshakeId</code> values (or the
<code>(initiatorNonce, responderNonce)</code> pair) and reject
duplicates within a configurable window (default: 5 minutes).</p>
<p><strong>Key Share Binding:</strong> The <code>keyShares[]</code>
array contains at most 2 entries (one PQC, one Classic) to bound message
size while enabling negotiation. Each entry is a
<code>(suiteId, shareBytes)</code> tuple. The Responder MUST select a
suite for which the Initiator provided a key share; otherwise reject
with <code>missingKeyShare</code>. This binds the negotiation to actual
cryptographic material, preventing the “TLS key_share mismatch” class of
bugs.</p>
<p><strong>Explicit Key Confirmation (Finished Frames):</strong>
Although the core key schedule is derived after MessageB, SkyBridge
Compass performs an explicit key-confirmation exchange before entering
the “established” state. The Responder sends a short
<code>Finished_R2I</code> frame authenticated under the newly derived
session keys; the Initiator verifies it and replies with
<code>Finished_I2R</code>. A session is considered established only
after both Finished frames are verified. This provides mutual key
confirmation, eliminates ambiguity about the establishment point, and
reduces responder-side half-open state under failures. The Finished
frames are fixed-size authenticated messages (38 bytes each: 4-byte
magic, 1-byte version, 1-byte direction, 32-byte HMAC) and add
negligible wire overhead compared to PQC handshake payloads. The
Finished MAC is computed as
<code>HMAC-SHA256(finishedKey, transcriptHash)</code> where
<code>finishedKey = HKDF(sessionKey, info="SkyBridge-FINISHED|&lt;role&gt;|")</code>.
Wire overhead for the full handshake including Finished frames is
reported in Table II.</p>
<p><strong>Anti-Downgrade Invariant:</strong> The Initiator MUST verify
that <code>selectedSuite</code> is a member of the
<code>supportedSuites[]</code> it originally sent AND that
<code>keyShares[]</code> contains an entry for
<code>selectedSuite</code>. Since <code>sigB</code> commits to
<code>MessageA</code> (via <code>transcriptA</code>), any modification
to <code>supportedSuites[]</code> or <code>keyShares[]</code> by an
attacker will cause <code>sigB</code> verification to fail.</p>
<p><strong>Suite Negotiation Scenarios:</strong></p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 32%" />
<col style="width: 14%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>Initiator supportedSuites</th>
<th>Responder Capability</th>
<th>Outcome</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>[PQC, Classic]</td>
<td>PQC available</td>
<td>PQC established</td>
<td>Best available selected</td>
</tr>
<tr>
<td>[PQC, Classic]</td>
<td>Classic only</td>
<td>Classic established</td>
<td>Graceful fallback</td>
</tr>
<tr>
<td>[PQC only]</td>
<td>Classic only</td>
<td>Handshake failed</td>
<td>Policy enforced</td>
</tr>
<tr>
<td>[Classic only]</td>
<td>PQC available</td>
<td>Classic established</td>
<td>Initiator policy respected</td>
</tr>
</tbody>
</table>
<p><strong>Message Field Validation Rules:</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 34%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr>
<th>Field</th>
<th>Validation</th>
<th>Failure Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>Must equal protocol version (1)</td>
<td>Reject with versionMismatch</td>
</tr>
<tr>
<td>supportedSuites</td>
<td>Must contain at least one suite supported by local implementation;
unknown IDs are ignored for negotiation but still transcript-bound</td>
<td>Reject with suiteNegotiationFailed</td>
</tr>
<tr>
<td>keyShares</td>
<td>Unique suiteId per entry, max 2 entries, each shareBytes must match
its suiteId’s expected length</td>
<td>Reject with invalidMessageFormat</td>
</tr>
<tr>
<td>selectedSuite</td>
<td>Must be in supportedSuites AND have matching keyShare</td>
<td>Reject with missingKeyShare</td>
</tr>
<tr>
<td>clientNonce/serverNonce</td>
<td>Must be 32 bytes</td>
<td>Reject with invalidMessageFormat</td>
</tr>
<tr>
<td>sigA/sigB</td>
<td>Must verify against respective identityPubKey</td>
<td>Reject with signatureVerificationFailed</td>
</tr>
</tbody>
</table>
<p><strong>Canonical Encoding Rules:</strong> -
<code>supportedSuites[]</code>: preference order, signed as-is (first =
most preferred) - <code>keyShares[]</code>: encoded in same order as
<code>supportedSuites[]</code> (only suites with provided shares) - All
lists use 2-byte little-endian length prefix - All integers use
little-endian encoding - Canonical encoding is byte-for-byte specified;
implementations MUST NOT reserialize with language-native encoders
(e.g., JSON, PropertyList) as this may introduce non-determinism</p>
<p>Note: The 32-byte <code>clientNonce</code>/<code>serverNonce</code>
in message fields are distinct from the 12-byte <code>aeadNonce</code>
used internally by AES-GCM for authenticated encryption.</p>
<p><strong>Failure Semantics:</strong> - All failures trigger
<code>HandshakeContext.zeroize()</code> before error propagation -
Security events are emitted for audit logging - No partial state is
retained after failure</p>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                    Application Layer                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐  │
│  │ Remote Desktop  │  │  File Transfer  │  │ Device Mgmt  │  │
│  └────────┬────────┘  └────────┬────────┘  └──────┬───────┘  │
└───────────┼────────────────────┼───────────────────┼─────────┘
            │                    │                   │
┌───────────┼────────────────────┼───────────────────┼─────────┐
│           ▼                    ▼                   ▼         │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Session Manager¹                      │ │
│  └─────────────────────────┬───────────────────────────────┘ │
│                            │                                 │
│  ┌─────────────────────────┼───────────────────────────────┐ │
│  │                         ▼                               │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌───────────────┐  │ │
│  │  │ Handshake    │  │CryptoProvider│  │ Transport     │  │ │
│  │  │ Driver       │&lt;─┤ Factory      │  │ Service       │  │ │
│  │  └──────┬───────┘  └──────┬───────┘  └───────────────┘  │ │
│  │         │                 │                             │ │
│  │         ▼                 ▼                             │ │
│  │  ┌──────────────┐  ┌──────────────────────────────────┐ │ │
│  │  │ Handshake    │  │        Provider Implementations  │ │ │
│  │  │ Context      │  │  ┌────────┐ ┌────────┐ ┌───────┐ │ │ │
│  │  │ (Actor)      │  │  │Apple   │ │ OQS    │ │Classic│ │ │ │
│  │  └──────────────┘  │  │PQC     │ │ PQC    │ │       │ │ │ │
│  │                    │  └────────┘ └────────┘ └───────┘ │ │ │
│  │                    └──────────────────────────────────┘ │ │
│  │                         P2P Core Layer                  │ │
│  └─────────────────────────────────────────────────────────┘ │
│                         Core Module²                         │
└──────────────────────────────────────────────────────────────┘

¹ Implementation: iOSP2PSessionManager
² Implementation: SkyBridgeCore module</code></pre>
<figure>
<img src="figures/fig_architecture.png"
alt="Fig. 1. SkyBridge Compass system architecture with trust boundaries and policy guard." />
<figcaption aria-hidden="true">Fig. 1. SkyBridge Compass system
architecture with trust boundaries and policy guard.</figcaption>
</figure>
<h3 id="b.-cryptoprovider-protocol">B. CryptoProvider Protocol</h3>
<p>The CryptoProvider protocol defines a unified interface for all
cryptographic operations required by the handshake and session layers.
This abstraction enables transparent substitution of underlying
implementations without modifying caller code.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">protocol</span> CryptoProvider<span class="op">:</span> <span class="dt">Sendable</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">providerName</span><span class="op">:</span> String <span class="op">{</span> <span class="kw">get</span> <span class="op">}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">tier</span><span class="op">:</span> CryptoTier <span class="op">{</span> <span class="kw">get</span> <span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">activeSuite</span><span class="op">:</span> CryptoSuite <span class="op">{</span> <span class="kw">get</span> <span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="fu">kemDemSeal</span><span class="op">(</span><span class="va">plaintext</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> <span class="va">recipientPublicKey</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                    <span class="va">info</span><span class="op">:</span> <span class="dt">Data</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">KemDemSealedBox</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="fu">kemDemOpen</span><span class="op">(</span><span class="va">sealedBox</span><span class="op">:</span> <span class="dt">KemDemSealedBox</span><span class="op">,</span> <span class="va">privateKey</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                    <span class="va">info</span><span class="op">:</span> <span class="dt">Data</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">Data</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="fu">sign</span><span class="op">(</span><span class="va">data</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> <span class="va">using</span> <span class="va">key</span><span class="op">:</span> <span class="dt">SigningKeyHandle</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">Data</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="fu">verify</span><span class="op">(</span><span class="va">data</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> <span class="va">signature</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">publicKey</span><span class="op">:</span> <span class="dt">Data</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">Bool</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="fu">generateKeyPair</span><span class="op">(</span><span class="va">for</span> <span class="va">usage</span><span class="op">:</span> <span class="dt">KeyUsage</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">KeyPair</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">/// Abstraction for signing keys: software or hardware-backed</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">enum</span> SigningKeyHandle<span class="op">:</span> <span class="dt">Sendable</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> softwareKey<span class="op">(</span>Data<span class="op">)</span>                    <span class="co">// Exportable private key bytes</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> secureEnclaveRef<span class="op">(</span>SecKey<span class="op">)</span>             <span class="co">// Hardware-backed, non-exportable</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> callback<span class="op">(</span>any SigningCallback<span class="op">)</span>        <span class="co">// Delegate to external signer</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>SigningKeyHandle</code> abstraction resolves the apparent
conflict between “private key as Data” and “Secure Enclave keys never
leave hardware.” Software keys are one variant; hardware-backed keys use
a reference or callback, ensuring the protocol interface does not assume
exportability.</p>
<p>The protocol mandates <code>Sendable</code> conformance, ensuring
thread-safe usage across Swift’s structured concurrency model. Each
provider exposes its tier classification (<code>nativePQC</code>,
<code>liboqsPQC</code>, or <code>classic</code>) and active cipher
suite, enabling runtime introspection for logging and policy
enforcement.</p>
<h3 id="c.-cryptosuite-wire-format">C. CryptoSuite Wire Format</h3>
<p>A <strong>suite</strong> defines the complete tuple
<code>(KEM, SIG, AEAD, KDF)</code>. Algorithm suite identifiers use a
structured 16-bit wire format enabling forward compatibility:</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 22%" />
<col style="width: 40%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th>Range</th>
<th>Category</th>
<th>Suite Components</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00xx</td>
<td>Hybrid PQC (preferred)</td>
<td>X-Wing KEM, ML-DSA-65, AES-256-GCM, HKDF-SHA256</td>
<td>0x0001</td>
</tr>
<tr>
<td>0x01xx</td>
<td>Pure PQC</td>
<td>ML-KEM-768, ML-DSA-65, AES-256-GCM, HKDF-SHA256</td>
<td>0x0101</td>
</tr>
<tr>
<td>0x10xx</td>
<td>Classic</td>
<td>X25519 DHKEM, Ed25519, AES-256-GCM, HKDF-SHA256</td>
<td>0x1001</td>
</tr>
<tr>
<td>0xF0xx</td>
<td>Experimental</td>
<td>Reserved for testing</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Note: X-Wing is a hybrid KEM combining X25519 + ML-KEM-768; it does
not include a signature algorithm. The suite identifier specifies the
full primitive set, with ML-DSA-65 as the <em>preferred</em> signature
algorithm when available; the current implementation may fall back to
classic signatures (Ed25519 / Secure Enclave P-256) for broader
OS/toolchain compatibility while keeping PQC confidentiality.</p>
<p>Unknown suite identifiers are parsed as <code>unknown(wireId)</code>
rather than causing parse failures, allowing older clients to gracefully
reject unsupported suites during negotiation.</p>
<h3 id="d.-provider-factory-and-selection">D. Provider Factory and
Selection</h3>
<p>The <code>CryptoProviderFactory</code> implements deterministic
provider selection based on runtime capability detection and policy
configuration:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">enum</span> CryptoProviderFactory <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">enum</span> SelectionPolicy<span class="op">:</span> <span class="dt">Sendable</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> preferPQC      <span class="co">// Default: best available</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> requirePQC     <span class="co">// Fail if PQC unavailable</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> classicOnly    <span class="co">// Force classic algorithms</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">static</span> <span class="kw">func</span> <span class="fu">make</span><span class="op">(</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">policy</span><span class="op">:</span> <span class="dt">SelectionPolicy</span> <span class="op">=</span> <span class="op">.</span>preferPQC<span class="op">,</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">environment</span><span class="op">:</span> <span class="dt">any</span> <span class="va">CryptoEnvironment</span> <span class="op">=</span> SystemCryptoEnvironment<span class="op">.</span>system</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span> -&gt; <span class="fu">any</span> <span class="fu">CryptoProvider</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The selection algorithm proceeds as follows:</p>
<ol type="1">
<li><strong>Capability Detection:</strong> Query the environment for
Apple PQC availability (macOS 26+) and liboqs presence.</li>
<li><strong>Policy Application:</strong> Match detected capabilities
against the requested policy.</li>
<li><strong>Provider Instantiation:</strong> Create the appropriate
provider instance.</li>
<li><strong>Event Emission:</strong> Emit a <code>SecurityEvent</code>
recording the selection decision.</li>
</ol>
<p>For <code>preferPQC</code> policy, the precedence order is:
ApplePQCProvider -&gt; OQSPQCProvider -&gt; ClassicProvider. The
<code>requirePQC</code> policy returns an
<code>UnavailablePQCProvider</code> that throws on all operations if no
PQC implementation is available.</p>
<h3 id="e.-kem-dem-authenticated-encryption-format">E. KEM-DEM
Authenticated Encryption Format</h3>
<p>The sealed box structure encapsulates KEM-based authenticated
encryption output with explicit DoS protection. Our construction follows
the KEM-DEM (Key Encapsulation Mechanism + Data Encapsulation Mechanism)
paradigm: KEM.Encapsulate() -&gt; HKDF-SHA256 -&gt; AES-256-GCM. We call
this an “HPKE-inspired KEM-DEM envelope” to distinguish it from RFC 9180
HPKE [13], which includes additional features such as multiple modes
(Base, PSK, Auth, AuthPSK), context exporters, and a more complex key
schedule.</p>
<p>On Apple 26+ platforms, CryptoKit provides native HPKE with
quantum-secure cipher suites including X-Wing (ML-KEM-768 + X25519)
[14]. When available, implementations SHOULD use CryptoKit’s HPKE API
directly rather than this compatibility envelope.</p>
<p><strong>Security Goals:</strong> - PQC suites: ML-KEM provides
IND-CCA2 KEM security (per FIPS 203) - Classic suites: X25519
ephemeral-DH encapsulation (DHKEM-style); security relies on the
X25519/Gap-DH assumption and HKDF key separation - INT-CTXT and IND-CPA
for the payload encryption: AES-256-GCM in v1 (compat KEM-DEM), and RFC
9180 HPKE AEAD in v2 (e.g., ChaCha20-Poly1305 in our classic provider) -
Key separation via HKDF with context-specific info parameters including
role binding</p>
<p><strong>Not Covered (delegated to RFC 9180 HPKE on Apple
26+):</strong> - Sender authentication modes (Auth, AuthPSK) -
Incremental AEAD for streaming</p>
<p><strong>Used in our handshake (classic v2):</strong> - HPKE exporter
for deriving the per-session shared secret with explicit context
binding</p>
<p><strong>Format Versions:</strong></p>
<p>The implementation supports two sealed box formats:</p>
<p><strong>v1 (Compatibility KEM-DEM):</strong> Used when native HPKE is
unavailable. Explicit nonce and tag fields.</p>
<pre><code>Header (17 bytes):
┌─────────┬───────────┬────────┬────────┐
│ magic   │ version   │ suite  │ flags  │
│ (4B)    │ (1B)      │ (2B)   │ (2B)   │
├─────────┼───────────┼────────┼────────┤
│ encLen  │ nonceLen  │ tagLen │ ctLen  │
│ (2B)    │ (1B)      │ (1B)   │ (4B)   │
└─────────┴───────────┴────────┴────────┘

Body (v1):
┌─────────────────┬───────┬────────────┬─────┐
│ encapsulatedKey │ nonce │ ciphertext │ tag │
│   (encLen)      │ (12B) │  (ctLen)   │(16B)│
└─────────────────┴───────┴────────────┴─────┘</code></pre>
<p><strong>v2 (Native HPKE):</strong> Used with CryptoKit HPKE. Nonce
and tag are embedded in the AEAD output.</p>
<pre><code>Header (17 bytes):
┌─────────┬───────────┬────────┬────────┐
│ magic   │ version   │ suite  │ flags  │
│ (4B)    │ (1B)      │ (2B)   │ (2B)   │
├─────────┼───────────┼────────┼────────┤
│ encLen  │ nonceLen  │ tagLen │ ctLen  │
│ (2B)    │ (0)       │ (0)    │ (4B)   │
└─────────┴───────────┴────────┴────────┘

Body (v2):
┌─────────────────┬────────────────────────────┐
│ encapsulatedKey │ ciphertext (AEAD output)   │
│   (encLen)      │ (ctLen, includes auth tag) │
└─────────────────┴────────────────────────────┘</code></pre>
<p><strong>Version Detection:</strong> Parsers distinguish v1 from v2 by
checking <code>nonceLen</code> and <code>tagLen</code>: - v1:
<code>nonceLen = 12</code>, <code>tagLen = 16</code> - v2:
<code>nonceLen = 0</code>, <code>tagLen = 0</code> (AEAD details
encapsulated by library)</p>
<p>Length limits enforce DoS protection: - <code>encLen</code> &lt;=
4096 bytes (sufficient for ML-KEM-768’s 1088-byte ciphertext) - v1:
<code>nonceLen</code> = 12 bytes (AES-GCM fixed), <code>tagLen</code> =
16 bytes (AES-GCM fixed) - v2: <code>nonceLen</code> = 0,
<code>tagLen</code> = 0 (embedded in ciphertext) - <code>ctLen</code>
&lt;= 64KB (handshake phase, pre-authentication) or 256KB
(post-authentication)</p>
<p>Parsing uses overflow-safe arithmetic and validates each field before
allocation.</p>
<hr />
<h2 id="iv.-handshake-state-machine">IV. HANDSHAKE STATE MACHINE</h2>
<h3 id="a.-design-principles">A. Design Principles</h3>
<p>The handshake subsystem addresses three critical requirements:</p>
<ol type="1">
<li><strong>Race Condition Prevention:</strong> Concurrent message
arrival and timeout expiration must not cause double-resume of
continuations.</li>
<li><strong>Sensitive Material Protection:</strong> Ephemeral private
keys and shared secrets must be zeroized on all exit paths.</li>
<li><strong>Observability:</strong> All state transitions and failures
must emit structured events.</li>
</ol>
<h3 id="b.-actor-isolated-architecture">B. Actor-Isolated
Architecture</h3>
<p>The <code>HandshakeDriver</code> actor manages handshake state with
compile-time data race prevention:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="cf">actor</span> HandshakeDriver <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">state</span><span class="op">:</span> HandshakeState <span class="op">=</span> <span class="op">.</span>idle</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">pendingContinuation</span><span class="op">:</span> CheckedContinuation<span class="op">&lt;</span>SessionKeys<span class="op">,</span> Error<span class="op">&gt;?</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">timeoutTask</span><span class="op">:</span> Task<span class="op">&lt;</span>Void<span class="op">,</span> Never<span class="op">&gt;?</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">pendingResult</span><span class="op">:</span> Result<span class="op">&lt;</span>SessionKeys<span class="op">,</span> Error<span class="op">&gt;?</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">func</span> <span class="fu">initiateHandshake</span><span class="op">(</span><span class="va">with</span> <span class="va">peer</span><span class="op">:</span> <span class="dt">PeerIdentifier</span><span class="op">)</span> </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">SessionKeys</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">func</span> <span class="fu">handleMessage</span><span class="op">(</span><span class="va">_</span> <span class="va">data</span><span class="op">:</span> <span class="dt">Data</span><span class="op">,</span> <span class="va">from</span> <span class="va">peer</span><span class="op">:</span> <span class="dt">PeerIdentifier</span><span class="op">)</span> <span class="fu">async</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">func</span> <span class="fu">cancel</span><span class="op">()</span> <span class="fu">async</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>HandshakeContext</code> actor isolates sensitive
cryptographic material:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="cf">actor</span> HandshakeContext <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">ephemeralPrivateKey</span><span class="op">:</span> SecureBytes<span class="op">?</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">transcriptHash</span><span class="op">:</span> SecureBytes<span class="op">?</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">var</span> <span class="va">isZeroized</span><span class="op">:</span> Bool <span class="op">=</span> <span class="kw">false</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">func</span> <span class="fu">zeroize</span><span class="op">()</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Reentrancy Considerations.</strong> Swift actors permit
method re-entry at suspension points (<code>await</code>). While actor
isolation prevents data races, it does not prevent interleaving of
method executions. Our <code>HandshakeDriver</code> mitigates reentrancy
risks through several mechanisms:</p>
<ol type="1">
<li><p><strong>Single convergence point:</strong> The
<code>finishOnce(with:)</code> method provides a single point for
handshake completion. It guards <code>pendingContinuation</code> access
and immediately sets the reference to <code>nil</code> after resume,
preventing double-resume even if called concurrently from timeout and
message handlers.</p></li>
<li><p><strong>Early result buffering:</strong> The
<code>pendingResult</code> property stores results that arrive before
the continuation is established (e.g., if <code>MessageB</code> arrives
before <code>withCheckedThrowingContinuation</code> captures the
continuation).</p></li>
<li><p><strong>Timeout cancellation:</strong> <code>timeoutTask</code>
is cancelled in <code>finishOnce</code>, preventing the race between
timeout expiration and successful message receipt.</p></li>
<li><p><strong>State advancement:</strong> State transitions occur
before <code>await</code> points where possible, reducing the window for
interleaved operations.</p></li>
</ol>
<p><strong>Acknowledged Limitation:</strong> The
<code>handleMessageB</code> method awaits <code>cryptoProvider</code>
operations inside the actor. If a new message arrives during this await,
the actor could theoretically process it before the current operation
completes. We mitigate this structurally by: - Advancing state to
<code>.processingMessageB</code> before the await, causing subsequent
messages to be rejected or queued - Copying all necessary immutable
inputs before the await point - Validating a monotonic epoch counter
after the await returns, ensuring the actor state has not been
invalidated by concurrent operations - Emitting security events for any
unexpected state transitions</p>
<p>This approach provides structural guarantees against reentrancy
hazards rather than relying on timing assumptions. A formal analysis
using model checking is planned for future work.</p>
<h3 id="c.-state-transitions">C. State Transitions</h3>
<p>Fig. 3 illustrates the handshake state machine for both roles.</p>
<p><img src="figures/fig_state_machine_initiator.png"
alt="Fig. 3a. Initiator handshake state machine with policy-aware failure gates." />
<img src="figures/fig_state_machine_responder.png"
alt="Fig. 3b. Responder handshake state machine with policy-aware failure gates." /></p>
<h3 id="d.-double-resume-prevention">D. Double-Resume Prevention</h3>
<p>The <code>finishOnce</code> method provides a single convergence
point for handshake completion:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="kw">func</span> <span class="fu">finishOnce</span><span class="op">(</span><span class="va">with</span> <span class="va">result</span><span class="op">:</span> <span class="dt">Result</span>&lt;<span class="va">SessionKeys</span><span class="op">,</span> <span class="va">Error</span>&gt;<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cancel timeout</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    timeoutTask<span class="op">?.</span>cancel<span class="op">()</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    timeoutTask <span class="op">=</span> <span class="kw">nil</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Guard against double resume</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">guard</span> <span class="kw">let</span> <span class="va">continuation</span> <span class="op">=</span> pendingContinuation <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// MessageB arrived before continuation established</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        pendingResult <span class="op">=</span> result</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    pendingContinuation <span class="op">=</span> <span class="kw">nil</span>  <span class="co">// Immediately nil to prevent reuse</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> result <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="op">.</span>success<span class="op">(</span><span class="kw">let</span> <span class="va">keys</span><span class="op">):</span> continuation<span class="op">.</span>resume<span class="op">(</span>returning<span class="op">:</span> keys<span class="op">)</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="op">.</span>failure<span class="op">(</span><span class="kw">let</span> <span class="va">error</span><span class="op">):</span> continuation<span class="op">.</span>resume<span class="op">(</span>throwing<span class="op">:</span> error<span class="op">)</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This pattern handles the race between timeout expiration and message
arrival by: 1. Canceling the timeout task on any completion 2. Guarding
continuation access with immediate nil assignment 3. Buffering early
results in <code>pendingResult</code> for late continuation
establishment</p>
<h3 id="e.-secure-zeroization">E. Secure Zeroization</h3>
<p>Swift’s standard <code>Data</code> and <code>Array</code> types use
copy-on-write (COW) semantics, which can leave uncontrolled copies of
sensitive material in memory. The <code>SecureBytes</code> class
addresses this by using manual <code>UnsafeMutableRawPointer</code>
allocation to maintain exclusive ownership of the memory region,
preventing COW-induced secret proliferation.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">final</span> <span class="kw">class</span> SecureBytes<span class="op">:</span> <span class="at">@unchecked</span> Sendable <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">let</span> <span class="va">pointer</span><span class="op">:</span> UnsafeMutableRawPointer</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="kw">let</span> <span class="va">count</span><span class="op">:</span> Int</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// Injectable wiping function for test verification</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    nonisolated<span class="op">(</span>unsafe<span class="op">)</span> <span class="kw">public</span> <span class="kw">static</span> <span class="kw">var</span> <span class="va">wipingFunction</span><span class="op">:</span> </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>UnsafeMutableRawPointer<span class="op">,</span> Int<span class="op">)</span> <span class="op">-&gt;</span> Void <span class="op">=</span> secureZero</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deinit</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> count <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            Self<span class="op">.</span>wipingFunction<span class="op">(</span>pointer<span class="op">,</span> count<span class="op">)</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        pointer<span class="op">.</span>deallocate<span class="op">()</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Design Rationale:</strong></p>
<ol type="1">
<li><p><strong>Avoiding Copy-on-Write:</strong> The primary motivation
for <code>SecureBytes</code> is to prevent COW semantics from creating
untracked copies of ephemeral keys and shared secrets. All sensitive
material in <code>HandshakeContext</code> uses <code>SecureBytes</code>
rather than <code>Data</code>.</p></li>
<li><p><strong>Explicit Zeroization on Failure Paths:</strong> Because
Swift’s ARC does not guarantee <code>deinit</code> timing, all failure
paths in <code>HandshakeDriver</code> explicitly call
<code>context.zeroize()</code> before error propagation. The
<code>deinit</code> zeroization serves as a defense-in-depth fallback,
not the primary mechanism.</p></li>
<li><p><strong>Compiler Optimization Resistance:</strong> On Darwin
platforms, zeroization uses platform-supported secure wipe primitives
where available, or <code>memset</code> followed by
<code>withExtendedLifetime</code> as a fallback. We aim for best-effort
zeroization; complete guarantees depend on compiler/runtime semantics
and are not formally provable in Swift today.</p></li>
<li><p><strong>Test Verification:</strong> The
<code>wipingFunction</code> is a static property that can be replaced
during testing. This enables verification that zeroization paths are
exercised on all failure modes, as demonstrated in Section
VII.B.1.</p></li>
</ol>
<h3 id="f.-transcript-binding-and-signature-separation">F. Transcript
Binding and Signature Separation</h3>
<p>The protocol uses domain-separated signatures to prevent
cross-message and cross-session replay attacks.</p>
<p><strong>Signature A (MessageA):</strong> The Initiator signs only
MessageA-local fields:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// preimageA: fields known to Initiator at MessageA time</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">preimageA</span> <span class="op">=</span> Data<span class="op">()</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> DS<span class="op">(</span><span class="st">&quot;SkyBridge-A&quot;</span><span class="op">)</span>                           <span class="co">// Domain separator</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> version<span class="op">.</span>encoded</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> supportedSuites<span class="op">.</span>canonicalEncode<span class="op">()</span>           <span class="co">// Preference order preserved</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> keyShares<span class="op">.</span>canonicalEncode<span class="op">()</span>                 <span class="co">// Bound to supportedSuites order</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> clientNonce                                 <span class="co">// 32 bytes</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> capabilities<span class="op">.</span>canonicalEncode<span class="op">()</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> policy<span class="op">.</span>canonicalEncode<span class="op">()</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> identityPubKey_I</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>sigA <span class="op">=</span> Sign<span class="op">(</span>preimageA<span class="op">,</span> identityPrivKey_I<span class="op">)</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Optional Secure Enclave binding (prevents SE proof replay)</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>seSigA <span class="op">=</span> SE_Sign<span class="op">(</span>DS<span class="op">(</span><span class="st">&quot;SkyBridge-SE-A&quot;</span><span class="op">)</span> <span class="op">||</span> SHA256<span class="op">(</span>preimageA<span class="op">))</span></span></code></pre></div>
<p><strong>Signature B (MessageB):</strong> The Responder signs a
transcript that commits to MessageA:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// transcriptA: hash of MessageA (excluding sigA and seSigA)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">transcriptA</span> <span class="op">=</span> SHA256<span class="op">(</span>MessageA_without_signatures<span class="op">)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">preimageB</span> <span class="op">=</span> Data<span class="op">()</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> DS<span class="op">(</span><span class="st">&quot;SkyBridge-B&quot;</span><span class="op">)</span>                           <span class="co">// Domain separator</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> transcriptA                                 <span class="co">// Commits to entire MessageA</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> selectedSuite<span class="op">.</span>wireId<span class="op">.</span>encoded</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> responderEphPubKey</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> serverNonce                                 <span class="co">// 32 bytes, fresh</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> SHA256<span class="op">(</span>encryptedPayload<span class="op">)</span>                    <span class="co">// Bind payload without bloating sig</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> identityPubKey_R</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>sigB <span class="op">=</span> Sign<span class="op">(</span>preimageB<span class="op">,</span> identityPrivKey_R<span class="op">)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Optional Secure Enclave binding</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>seSigB <span class="op">=</span> SE_Sign<span class="op">(</span>DS<span class="op">(</span><span class="st">&quot;SkyBridge-SE-B&quot;</span><span class="op">)</span> <span class="op">||</span> SHA256<span class="op">(</span>preimageB<span class="op">))</span></span></code></pre></div>
<p><strong>Key Derivation:</strong> Nonces, transcripts, suite binding,
and <em>directional separation</em> are included in the KDF, and the
salt is transcript-bound (non-empty):</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">kdfInfo</span> <span class="op">=</span> Data<span class="op">()</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> DS<span class="op">(</span><span class="st">&quot;SkyBridge-KDF&quot;</span><span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> selectedSuite<span class="op">.</span>wireId<span class="op">.</span>encodedLE</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> transcriptA</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> transcriptB                      <span class="co">// e.g., SHA256(MessageB_without_signatures)</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> clientNonce</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> serverNonce</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Transcript-bound salt (prevents cross-context reuse)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">salt</span> <span class="op">=</span> SHA256<span class="op">(</span>DS<span class="op">(</span><span class="st">&quot;SkyBridge-KDF-Salt-v1|&quot;</span><span class="op">)</span> <span class="op">||</span> kdfInfo<span class="op">)</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Direction-based symmetric key derivation</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Both sides derive the same key for each direction:</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">// - initiator_to_responder: Initiator&#39;s sendKey = Responder&#39;s receiveKey</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">// - responder_to_initiator: Responder&#39;s sendKey = Initiator&#39;s receiveKey</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">i2rInfo</span> <span class="op">=</span> kdfInfo <span class="op">+</span> DS<span class="op">(</span><span class="st">&quot;handshake|initiator_to_responder&quot;</span><span class="op">)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">r2iInfo</span> <span class="op">=</span> kdfInfo <span class="op">+</span> DS<span class="op">(</span><span class="st">&quot;handshake|responder_to_initiator&quot;</span><span class="op">)</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">// For Initiator: sendKey = I2R, receiveKey = R2I</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co">// For Responder: sendKey = R2I, receiveKey = I2R</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">sendKey</span> <span class="op">=</span> HKDF<span class="op">&lt;</span>SHA256<span class="op">&gt;.</span>deriveKey<span class="op">(</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    inputKeyMaterial<span class="op">:</span> sharedSecret<span class="op">,</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    salt<span class="op">:</span> salt<span class="op">,</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    info<span class="op">:</span> role <span class="op">==</span> <span class="op">.</span>initiator <span class="op">?</span> i2rInfo <span class="op">:</span> r2iInfo<span class="op">,</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    outputByteCount<span class="op">:</span> <span class="dv">32</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">receiveKey</span> <span class="op">=</span> HKDF<span class="op">&lt;</span>SHA256<span class="op">&gt;.</span>deriveKey<span class="op">(</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    inputKeyMaterial<span class="op">:</span> sharedSecret<span class="op">,</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    salt<span class="op">:</span> salt<span class="op">,</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    info<span class="op">:</span> role <span class="op">==</span> <span class="op">.</span>initiator <span class="op">?</span> r2iInfo <span class="op">:</span> i2rInfo<span class="op">,</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    outputByteCount<span class="op">:</span> <span class="dv">32</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>This structure ensures: (1) <code>sigB</code> commits to
<code>MessageA</code>, so any tampering breaks verification; (2) domain
separators prevent cross-protocol attacks; (3) SE signatures are
session-bound and non-replayable.</p>
<hr />
<h2 id="v.-security-model-and-guarantees">V. SECURITY MODEL AND
GUARANTEES</h2>
<h3 id="a.-security-model">A. Security Model</h3>
<p>We assume an active network adversary with full control of the
discovery channel (drop, delay, reorder, duplicate, modify, and inject
messages) but without breaking standard cryptographic assumptions. The
attacker can replay prior handshakes and attempt downgrade by
suppressing PQC-related fields. We assume the out-of-band pairing
ceremony is trusted and that device key storage (Keychain/Secure
Enclave) preserves key integrity. The attacker may compromise a peer
after pairing, but cannot retroactively forge signatures for past
sessions.</p>
<h3 id="b.-security-goals-and-proof-sketches">B. Security Goals and
Proof Sketches</h3>
<p>We state the core properties as invariants and provide non-formal
proof sketches tied to protocol mechanics:</p>
<p><strong>Property G1 (Negotiation Integrity):</strong> The selected
suite must be among the Initiator’s offered suites and have a
corresponding key share.<br />
<em>Proof sketch:</em> <code>MessageB</code> includes
<code>selectedSuite</code>, and <code>sigB</code> covers
<code>MessageA</code>; any modification to
<code>supportedSuites[]</code> or <code>keyShares[]</code> breaks
<code>sigB</code> verification. The Responder validates
<code>selectedSuite in supportedSuites[]</code> and
<code>keyShares[]</code> contains a matching entry.</p>
<p><strong>Property G2 (Mutual Authentication for Paired
Peers):</strong> For previously paired devices, the peer identity is
authenticated and bound to the handshake transcript.<br />
<em>Proof sketch:</em> <code>identityPubKey</code> is pinned during OOB
pairing. <code>MessageA</code>/<code>MessageB</code> signatures over
transcript data must verify under the pinned key, otherwise
<code>identityMismatch</code> aborts the handshake.</p>
<p><strong>Property G3 (Session Key Secrecy):</strong> The derived
session keys remain secret under standard KEM/DH and signature security
assumptions.<br />
<em>Proof sketch:</em> The shared secret is derived from KEM
decapsulation or DH, and keys are extracted via HKDF with
transcript-bound salt; an attacker without the private key material
cannot compute the shared secret or derive session keys.</p>
<p><strong>Property G4 (Replay Resistance):</strong> Replayed handshakes
do not establish a session.<br />
<em>Proof sketch:</em> <code>handshakeId</code> derives from fresh
nonces and suite identifiers; replay detection caches recent IDs and
rejects duplicates within the window.</p>
<p><strong>Property G5 (Downgrade Resistance under strictPQC):</strong>
No fallback to classic is allowed under strict policy.<br />
<em>Proof sketch:</em> <code>TwoAttemptHandshakeManager</code> enforces
a policy gate before any fallback attempt; strictPQC forbids all
fallback edges regardless of error type. This is validated by policy
downgrade benchmarks (Fig. 6).</p>
<p><strong>Property G6 (Safe Fallback under default policy):</strong>
Fallback can only occur for a whitelisted set of benign errors, and
never due to timeout.<br />
<em>Proof sketch:</em> A whitelist/blacklist of error causes controls
fallback; <code>timeout</code> is explicitly blocked and per-peer
cooldown limits repeated downgrades.</p>
<p><strong>Property G7 (Legacy Acceptance Preconditions):</strong>
Legacy P-256 signatures are accepted only under authenticated pairing or
an existing trust record.<br />
<em>Proof sketch:</em> Legacy acceptance is gated by
<code>LegacyTrustPrecondition</code>; pure network stranger connections
fail. This is validated by the precondition test matrix (Table
VIII).</p>
<p><strong>Property G8 (Auditability):</strong> Cryptographic downgrades
and exceptional states are observable.<br />
<em>Proof sketch:</em> The handshake emits
<code>handshakeFallback</code>/<code>cryptoDowngrade</code> events with
reason, deviceId, and cooldown context, enabling post-hoc verification
of policy adherence.</p>
<p><strong>TABLE XIII: Security Contract (Properties, Enforcement,
Evidence)</strong></p>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 39%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Property</th>
<th>Enforced at</th>
<th>Evidence</th>
</tr>
</thead>
<tbody>
<tr>
<td>G1 Negotiation integrity</td>
<td>Suite/keyshare validation + transcript-bound <code>sigB</code></td>
<td>Fig. 2, Table IX, HandshakeDriverTests</td>
</tr>
<tr>
<td>G2 Mutual authentication</td>
<td>Identity pinning + signature verification</td>
<td>Table V (wrong signature), Table VIII</td>
</tr>
<tr>
<td>G3 Session key secrecy</td>
<td>KEM/DH + HKDF with transcript-bound salt</td>
<td>Property 1, Table VI</td>
</tr>
<tr>
<td>G4 Replay resistance</td>
<td><code>handshakeId</code> cache + nonce binding</td>
<td>Property-Oriented Testing (Section VII.B.3)</td>
</tr>
<tr>
<td>G5 strictPQC no-downgrade</td>
<td>Policy gate in TwoAttemptHandshakeManager</td>
<td>Fig. 6, PolicyDowngradeBenchTests</td>
</tr>
<tr>
<td>G6 Default safe fallback</td>
<td>Whitelist/blacklist + cooldown</td>
<td>Fig. 7, Table V</td>
</tr>
<tr>
<td>G7 Legacy acceptance precondition</td>
<td>LegacyTrustPrecondition</td>
<td>Table VIII</td>
</tr>
<tr>
<td>G8 Auditability</td>
<td>Security event emission</td>
<td>Fig. 8, Table XIV</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="vi.-implementation">VI. IMPLEMENTATION</h2>
<h3 id="a.-platform-support-matrix">A. Platform Support Matrix</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 32%" />
<col style="width: 27%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>Platform</th>
<th>PQC Provider</th>
<th>Algorithms</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>macOS 26+</td>
<td>ApplePQCProvider</td>
<td>ML-KEM-768, ML-KEM-1024¹, ML-DSA-65, ML-DSA-87¹</td>
<td>Native CryptoKit</td>
</tr>
<tr>
<td>macOS 14–15</td>
<td>OQSPQCProvider</td>
<td>ML-KEM-768, ML-DSA-65</td>
<td>liboqs fallback</td>
</tr>
<tr>
<td>macOS 14–15</td>
<td>ClassicProvider</td>
<td>X25519, Ed25519</td>
<td>If liboqs unavailable</td>
</tr>
<tr>
<td>iOS 26+</td>
<td>ApplePQCProvider</td>
<td>ML-KEM-768, ML-KEM-1024¹, ML-DSA-65, ML-DSA-87¹</td>
<td>Native CryptoKit</td>
</tr>
<tr>
<td>iOS 17–18</td>
<td>ClassicProvider</td>
<td>X25519, Ed25519</td>
<td>liboqs not bundled</td>
</tr>
</tbody>
</table>
<p>Fallback semantics: the provider selection is
deterministic—ApplePQCProvider on macOS/iOS 26+ (CryptoKit
ML-KEM/ML-DSA, Secure Enclave backed when available), otherwise
OQSPQCProvider on macOS 14–15 (liboqs ML-KEM-768/ML-DSA-65), and finally
ClassicProvider (X25519/Ed25519) when PQC is unavailable. Secure Enclave
P-256 ECDSA proof-of-possession is optional and orthogonal to the PQC
suite.</p>
<p>Note: Apple unified macOS and iOS version numbers starting with
version 26 (announced WWDC 2025). macOS 16–25 and iOS 19–25 were never
released.</p>
<p>¹ ML-KEM-1024 and ML-DSA-87 are available in CryptoKit on Apple 26+
but not currently used by our implementation. X-Wing hybrid KEM (wireId
0x0001) is reserved for future use. Secure Enclave–backed PQC keys are
only available on Apple 26+; earlier versions fall back to software PQC
and P-256 Secure Enclave PoP.</p>
<h3 id="b.-apple-pqc-integration">B. Apple PQC Integration</h3>
<p>The <code>ApplePQCCryptoProvider</code> wraps CryptoKit’s ML-KEM and
ML-DSA APIs with a KEM-based authenticated encryption construction:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>#if HAS_APPLE_PQC_SDK</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="at">@available</span><span class="op">(</span>macOS <span class="fl">26.0</span><span class="op">,</span> <span class="op">*)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">struct</span> ApplePQCCryptoProvider<span class="op">:</span> <span class="dt">CryptoProvider</span><span class="op">,</span> <span class="dt">Sendable</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">func</span> <span class="fu">kemDemSeal</span><span class="op">(</span>...<span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">KemDemSealedBox</span> <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// KEM encapsulation</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">publicKey</span> <span class="op">=</span> <span class="cf">try</span> MLKEM768<span class="op">.</span>PublicKey<span class="op">(</span>rawRepresentation<span class="op">:</span> recipientPublicKey<span class="op">)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">encapsulationResult</span> <span class="op">=</span> <span class="cf">try</span> publicKey<span class="op">.</span>encapsulate<span class="op">()</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Key derivation (HKDF-SHA256)</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">salt</span> <span class="op">=</span> SHA256<span class="op">(</span>DS<span class="op">(</span><span class="st">&quot;SkyBridge-KDF-Salt-v1|&quot;</span><span class="op">)</span> <span class="op">||</span> info<span class="op">)</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">derivedKey</span> <span class="op">=</span> HKDF<span class="op">&lt;</span>SHA256<span class="op">&gt;.</span>deriveKey<span class="op">(</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>            inputKeyMaterial<span class="op">:</span> encapsulationResult<span class="op">.</span>sharedSecret<span class="op">,</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>            salt<span class="op">:</span> salt<span class="op">,</span> info<span class="op">:</span> info<span class="op">,</span> outputByteCount<span class="op">:</span> <span class="dv">32</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Authenticated encryption (AES-256-GCM)</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">sealedBox</span> <span class="op">=</span> <span class="cf">try</span> AES<span class="op">.</span>GCM<span class="op">.</span>seal<span class="op">(</span>plaintext<span class="op">,</span> using<span class="op">:</span> derivedKey<span class="op">)</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> KemDemSealedBox<span class="op">(</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>            encapsulatedKey<span class="op">:</span> encapsulationResult<span class="op">.</span>encapsulated<span class="op">,</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>            nonce<span class="op">:</span> Data<span class="op">(</span>sealedBox<span class="op">.</span>nonce<span class="op">),</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>            ciphertext<span class="op">:</span> sealedBox<span class="op">.</span>ciphertext<span class="op">,</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>            tag<span class="op">:</span> sealedBox<span class="op">.</span>tag</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>#endif</span></code></pre></div>
<p>This construction (KEM -&gt; HKDF -&gt; AEAD) is inspired by HPKE
[13] but does not implement the full RFC 9180 specification. On Apple
26+ platforms, CryptoKit exposes HPKE cipher suites including X-Wing
(ML-KEM-768 with X25519), enabling a standards-aligned replacement for
our compatibility envelope [14]. This layer can then be replaced with
direct CryptoKit PQ-HPKE calls.</p>
<h3 id="c.-conditional-compilation-strategy">C. Conditional Compilation
Strategy</h3>
<p>The <code>HAS_APPLE_PQC_SDK</code> flag gates <strong>all</strong>
PQC type references. Importantly, <code>@available</code> only controls
<em>runtime</em> availability; it does not prevent <em>compile-time</em>
failures when the SDK lacks the PQC symbols.</p>
<p>For reproducible builds across toolchains, we intentionally
<strong>do not</strong> enable <code>HAS_APPLE_PQC_SDK</code> by default
in SwiftPM (because <code>.when(platforms: [.macOS])</code> does not
reflect SDK availability and will break older Xcode builds). Instead,
projects inject the flag from build settings <strong>only</strong> when
compiling with the Apple 26 SDK (Xcode 26+):</p>
<pre class="text"><code>OTHER_SWIFT_FLAGS = \$(inherited) -DHAS_APPLE_PQC_SDK</code></pre>
<p>This keeps the codebase buildable on older Xcode versions (classic
provider path), while enabling native CryptoKit PQC providers only when
the correct SDK is present.</p>
<h3 id="d.-security-event-emission">D. Security Event Emission</h3>
<p>All cryptographic decisions emit structured events:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>SecurityEventEmitter<span class="op">.</span>emitDetached<span class="op">(</span>SecurityEvent<span class="op">(</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    type<span class="op">:</span> <span class="op">.</span>cryptoProviderSelected<span class="op">,</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    severity<span class="op">:</span> fallbackFromPreferred <span class="op">?</span> <span class="op">.</span>warning <span class="op">:</span> <span class="op">.</span>info<span class="op">,</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    message<span class="op">:</span> <span class="st">&quot;Crypto provider selected: </span><span class="er">\(</span><span class="st">provider.providerName)&quot;</span><span class="op">,</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    context<span class="op">:</span> <span class="op">[</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;selectedTier&quot;</span><span class="op">:</span> selectedTier<span class="op">.</span>rawValue<span class="op">,</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;fallbackFromPreferred&quot;</span><span class="op">:</span> String<span class="op">(</span>fallbackFromPreferred<span class="op">),</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;suite&quot;</span><span class="op">:</span> provider<span class="op">.</span>activeSuite<span class="op">.</span>rawValue<span class="op">,</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;osVersion&quot;</span><span class="op">:</span> capability<span class="op">.</span>osVersion</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">]</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="op">))</span></span></code></pre></div>
<p>The <code>SecurityEventEmitter</code> actor implements backpressure
with per-subscriber queues and meta-event rate limiting to prevent
recursive overflow.</p>
<h3 id="e.-secure-enclave-integration">E. Secure Enclave
Integration</h3>
<p>For hardware-backed signing, the <code>SigningCallback</code>
protocol enables Secure Enclave integration:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">protocol</span> SigningCallback<span class="op">:</span> <span class="dt">Sendable</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">func</span> <span class="fu">sign</span><span class="op">(</span><span class="va">data</span><span class="op">:</span> <span class="dt">Data</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">Data</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="at">@available</span><span class="op">(</span>macOS <span class="fl">26.0</span><span class="op">,</span> iOS <span class="fl">26.0</span><span class="op">,</span> <span class="op">*)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">struct</span> SecureEnclaveSigningCallback<span class="op">:</span> <span class="dt">SigningCallback</span> <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">func</span> <span class="fu">sign</span><span class="op">(</span><span class="va">data</span><span class="op">:</span> <span class="dt">Data</span><span class="op">)</span> <span class="fu">async</span> <span class="kw">throws</span> -&gt; <span class="fu">Data</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="va">query</span><span class="op">:</span> <span class="op">[</span>String<span class="op">:</span> Any<span class="op">]</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            kSecClass <span class="kw">as</span> String<span class="op">:</span> kSecClassKey<span class="op">,</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            kSecAttrApplicationTag <span class="kw">as</span> String<span class="op">:</span> keyTag<span class="op">,</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            kSecAttrKeyType <span class="kw">as</span> String<span class="op">:</span> kSecAttrKeyTypeECSECPrimeRandom<span class="op">,</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>            kSecReturnRef <span class="kw">as</span> String<span class="op">:</span> <span class="kw">true</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ... SecKey operations</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>HandshakeDriver</code> prioritizes callback-based signing
over raw key material, ensuring private keys never leave the Secure
Enclave.</p>
<p><strong>Availability and fallback:</strong> Secure Enclave–backed
ML-DSA/ML-KEM keys are only available on macOS 26+ via CryptoKit. On
macOS 14–15, PQC operations fall back to liboqs (software), and Secure
Enclave is used only for P-256 ECDSA proof-of-possession keys. When
Secure Enclave PQC is used, the implementation relies on CryptoKit’s
<code>SecureEnclave.MLDSA*</code> / <code>SecureEnclave.MLKEM*</code>
key types, which are gated by the macOS 26+ SDK and runtime availability
checks.</p>
<h3 id="f.-signing-key-hierarchy">F. Signing Key Hierarchy</h3>
<p>The system supports two complementary signing mechanisms:</p>
<ol type="1">
<li><p><strong>CryptoProvider signing (Protocol Signature):</strong>
Uses the active suite’s signature algorithm (Ed25519 for classic,
ML-DSA-65 for PQC) for protocol-level identity verification. Keys are
managed by the CryptoProvider and stored in software. This is the
primary signature used in <code>sigA</code>/<code>sigB</code> fields of
handshake messages.</p></li>
<li><p><strong>Secure Enclave signing (Device PoP):</strong> Uses EC
P-256 with ECDSA via <code>SecureEnclaveSigningCallback</code> to prove
the peer controls a key stored in Secure Enclave. Private keys never
leave the Secure Enclave hardware. Note: This provides
proof-of-possession of a hardware-backed key, not full device
attestation (Apple does not expose a general-purpose attestation API
with certificate chains at the application layer). The security value
derives from the key being pinned during initial pairing.</p></li>
</ol>
<p><strong>Implementation Note:</strong> The
<code>DeviceIdentityKeyManager</code> creates P-256 keys in Secure
Enclave (when available) for hardware-backed device identity. These keys
are used for the optional <code>seSigA</code>/<code>seSigB</code>
proof-of-possession signatures, NOT for the primary protocol signatures
(<code>sigA</code>/<code>sigB</code>). The primary protocol signatures
use Ed25519 (classic) or ML-DSA-65 (PQC) keys generated by the
CryptoProvider.</p>
<p>The <code>FallbackSigningCallback</code> provides automatic fallback
from Secure Enclave to CryptoProvider when hardware signing is
unavailable (e.g., on devices without Secure Enclave or when the key has
not been provisioned).</p>
<p><strong>Use Case Separation:</strong> - CryptoProvider
(Ed25519/ML-DSA): Primary protocol signatures, cross-platform
interoperability, suite-negotiated - Secure Enclave (P-256 ECDSA):
Optional hardware-backed proof-of-possession, proving control of a
non-exportable key</p>
<p>Both mechanisms can coexist in a single handshake: CryptoProvider for
primary protocol signatures (<code>sigA</code>/<code>sigB</code>),
Secure Enclave for optional hardware-backed proof-of-possession
(<code>seSigA</code>/<code>seSigB</code>).</p>
<p><strong>Signature Verification Rules:</strong> 1. <code>sigA</code>
(Ed25519 or ML-DSA per suite) is mandatory in MessageA and must verify
against <code>identityPubKey_I</code> 2. <code>sigB</code> (Ed25519 or
ML-DSA per suite) is mandatory in MessageB and must verify against
<code>identityPubKey_R</code>; additionally, <code>sigB</code> commits
to <code>transcriptA</code>, so Initiator implicitly verifies MessageA
was received unmodified 3. For paired peers: <code>identityPubKey</code>
MUST match the pinned key from initial pairing; mismatch triggers
<code>identityMismatch</code> rejection 4.
<code>seSigA</code>/<code>seSigB</code> (P-256 ECDSA from Secure
Enclave) are optional; if present and valid, the peer’s trust level is
elevated. These signatures are domain-separated and session-bound,
preventing replay across sessions. 5. Verification order:
<code>sigA</code>/<code>sigB</code> first, then identity pinning check,
then optional SE signature 6. Failure semantics: missing SE signature is
acceptable (devices without Secure Enclave); invalid SE signature
triggers <code>secureEnclaveSignatureInvalid</code> event but may still
allow connection at reduced trust level per policy</p>
<h3
id="g.-pre-negotiation-signature-algorithm-selection-and-two-attempt-strategy">G.
Pre-Negotiation Signature Algorithm Selection and Two-Attempt
Strategy</h3>
<p>A fundamental challenge in our protocol is the “chicken-and-egg”
problem: <code>sigA</code> must be generated <em>before</em> suite
negotiation completes, yet the signature algorithm should be consistent
with the negotiated suite. We resolve this through
<strong>pre-negotiation signature selection</strong> and a
<strong>two-attempt strategy</strong>.</p>
<p><strong>Pre-Negotiation Signature Selection:</strong></p>
<p>The signature algorithm for <code>sigA</code> is determined by the
<code>offeredSuites</code> in MessageA, not by the final
<code>selectedSuite</code>:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> <span class="kw">func</span> <span class="fu">selectForMessageA</span><span class="op">(</span><span class="va">offeredSuites</span><span class="op">:</span> [<span class="dt">CryptoSuite</span>]<span class="op">)</span> -&gt; <span class="fu">ProtocolSigningAlgorithm</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">hasPQCOrHybrid</span> <span class="op">=</span> offeredSuites<span class="op">.</span>contains <span class="op">{</span> \$<span class="fl">0.</span>isPQCGroup <span class="op">}</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> hasPQCOrHybrid <span class="op">?</span> <span class="op">.</span>mlDSA65 <span class="op">:</span> <span class="op">.</span>ed25519</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Homogeneity Invariant:</strong> Each attempt’s
<code>offeredSuites</code> must be <em>homogeneous</em> with respect to
<code>sigAAlgorithm</code>: - If <code>sigAAlgorithm</code> is
ML-DSA-65, ALL suites in <code>offeredSuites</code> must have
<code>isPQCGroup == true</code> - If <code>sigAAlgorithm</code> is
Ed25519, ALL suites in <code>offeredSuites</code> must have
<code>isPQCGroup == false</code></p>
<p>This invariant is enforced at compile-time through the type system
(<code>ProtocolSigningAlgorithm</code> excludes P-256) and at runtime
through <code>HandshakeDriver</code> initialization validation.</p>
<p><strong>Two-Attempt Strategy:</strong></p>
<p>To support interoperability between PQC-capable and classic-only
devices while maintaining the homogeneity invariant, we employ a
two-attempt strategy:</p>
<ol type="1">
<li><strong>PQC Attempt (preferPQC=true):</strong> First attempt with
<code>offeredSuites</code> containing only PQC/Hybrid suites and
<code>sigAAlgorithm = ML-DSA-65</code></li>
<li><strong>Classic Fallback:</strong> If PQC attempt fails due to
provider unavailability or suite negotiation failure, fall back to
classic-only <code>offeredSuites</code> with
<code>sigAAlgorithm = Ed25519</code></li>
</ol>
<div class="sourceCode" id="cb19"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">static</span> <span class="kw">func</span> <span class="fu">prepareAttempt</span><span class="op">(</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">strategy</span><span class="op">:</span> <span class="dt">HandshakeAttemptStrategy</span><span class="op">,</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">cryptoProvider</span><span class="op">:</span> <span class="dt">any</span> <span class="va">CryptoProvider</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="kw">throws</span> -&gt; <span class="fu">AttemptPreparation</span> <span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 1. Build homogeneous offeredSuites from provider&#39;s supported suites</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">buildResult</span> <span class="op">=</span> HandshakeOfferedSuites<span class="op">.</span>build<span class="op">(</span>strategy<span class="op">:</span> strategy<span class="op">,</span> cryptoProvider<span class="op">:</span> cryptoProvider<span class="op">)</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2. Select signature algorithm based on suites</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">sigAAlgorithm</span> <span class="op">=</span> PreNegotiationSignatureSelector<span class="op">.</span>selectForMessageAResult<span class="op">(</span>offeredSuites<span class="op">:</span> suites<span class="op">)</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 3. Get matching signature provider</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="va">signatureProvider</span> <span class="op">=</span> PreNegotiationSignatureSelector<span class="op">.</span>selectProvider<span class="op">(</span><span class="cf">for</span><span class="op">:</span> sigAAlgorithm<span class="op">)</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> AttemptPreparation<span class="op">(</span>strategy<span class="op">,</span> suites<span class="op">,</span> sigAAlgorithm<span class="op">,</span> signatureProvider<span class="op">)</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Fallback Security:</strong></p>
<p>Not all failures trigger fallback. The system maintains a whitelist
of safe fallback reasons and a blacklist of security-critical
failures:</p>
<ul>
<li><strong>Allowed:</strong> <code>pqcProviderUnavailable</code>,
<code>suiteNotSupported</code>, <code>suiteNegotiationFailed</code></li>
<li><strong>Blocked:</strong> <code>timeout</code>,
<code>suiteSignatureMismatch</code>,
<code>signatureVerificationFailed</code>, <code>identityMismatch</code>,
<code>replayDetected</code></li>
</ul>
<p>Timeout-based fallback is explicitly blocked to prevent attackers
from forcing downgrade through packet dropping. Per-peer fallback is
rate-limited (5-minute cooldown) to prevent rapid downgrade cycling.</p>
<p><strong>Security Events:</strong></p>
<p>Every fallback emits a <code>handshakeFallback</code> event with full
context (reason, deviceId, cooldown), enabling audit and anomaly
detection.</p>
<hr />
<h2 id="vii.-evaluation">VII. EVALUATION</h2>
<h3 id="a.-experimental-setup">A. Experimental Setup</h3>
<p>We evaluate SkyBridge Compass along two primary tracks:
<strong>security-centric evidence</strong> (fault injection, downgrade
suppression, legacy precondition enforcement, and auditability) and
<strong>cost-centric evidence</strong> (handshake latency, wire
overhead, provider selection overhead, and data-plane throughput). All
experiments are run on Apple Silicon (ARM64) on macOS 26.x, where
CryptoKit PQC is available when the SDK exposes ML-KEM/ML-DSA types.</p>
<p><strong>Test Environment:</strong> - Apple Silicon Macs (M1/M3
class), macOS 26.x (CryptoKit PQC when available; liboqs PQC via library
backend)</p>
<p><strong>Build Configuration:</strong> Release (<code>-O</code>) with
non-essential logging disabled. Timing uses a monotonic clock
(<code>ContinuousClock</code>) and records: warmup iterations discarded,
then a fixed number of measured iterations. Reported percentiles are
computed directly from samples.</p>
<p><strong>Reproducibility:</strong> We ship an opt-in benchmark test
suite under <code>Tests/SkyBridgeCoreTests/</code>. For a one-shot run,
use <code>Scripts/run_paper_eval.sh</code>. The following commands
reproduce the paper’s tables:</p>
<ul>
<li><strong>Table I (Handshake Latency):</strong>
<code>SKYBRIDGE_RUN_BENCH=1 swift test --filter HandshakeBenchmarkTests</code></li>
<li><strong>Table I-B (Handshake RTT):</strong>
<code>SKYBRIDGE_RUN_BENCH=1 swift test --filter HandshakeBenchmarkTests</code></li>
<li><strong>Table II (Handshake Message Sizes):</strong>
<code>SKYBRIDGE_RUN_BENCH=1 swift test --filter HandshakeBenchmarkTests</code></li>
<li><strong>Table III (Data-Plane Throughput):</strong>
<code>SKYBRIDGE_RUN_BENCH=1 swift test --filter testBench_DataPlaneThroughputAndCPUProxy</code></li>
<li><strong>Table IV (Provider Selection):</strong>
<code>SKYBRIDGE_RUN_BENCH=1 swift test --filter testBench_ProviderSelectionOverhead</code></li>
<li><strong>Table V (Fault Injection):</strong>
<code>SKYBRIDGE_RUN_FI=1 swift test --filter HandshakeFaultInjectionBenchTests</code></li>
<li><strong>Message Size Breakdown (Fig. 5):</strong>
<code>swift test --filter MessageSizeSnapshotTests</code></li>
<li><strong>Policy Downgrade Bench (Fig. 6):</strong>
<code>SKYBRIDGE_RUN_POLICY_BENCH=1 swift test --filter PolicyDowngradeBenchTests</code></li>
<li><strong>Migration Coverage Bench (Table VIII coverage):</strong>
<code>SKYBRIDGE_RUN_MIGRATION_BENCH=1 swift test --filter MigrationCoverageBenchTests</code></li>
<li><strong>Downgrade Matrix (Fig. 7):</strong> derived from
<code>TwoAttemptHandshakeManager.shouldAllowFallback</code>
whitelist/blacklist</li>
<li><strong>Failure Histogram (Fig. 8):</strong>
<code>SKYBRIDGE_RUN_FI=1 swift test --filter HandshakeFaultInjectionBenchTests</code>
+
<code>SKYBRIDGE_RUN_POLICY_BENCH=1 swift test --filter PolicyDowngradeBenchTests</code>,
then <code>Scripts/plot_failure_histogram.py</code></li>
<li><strong>Audit-Signal Fidelity (Fig. 9 / Table XIV):</strong>
<code>Scripts/derive_audit_signal_fidelity.py</code> (inputs
<code>fault_injection_&lt;date&gt;.csv</code>,
<code>policy_downgrade_&lt;date&gt;.csv</code>; outputs
<code>audit_signal_fidelity_&lt;date&gt;.csv</code>)</li>
</ul>
<p>Results are written to <code>Artifacts/</code> as CSV files (e.g.,
<code>handshake_bench_&lt;date&gt;.csv</code>,
<code>handshake_rtt_&lt;date&gt;.csv</code>,
<code>handshake_wire_&lt;date&gt;.csv</code>,
<code>message_sizes_&lt;date&gt;.csv</code>,
<code>fault_injection_&lt;date&gt;.csv</code>,
<code>policy_downgrade_&lt;date&gt;.csv</code>,
<code>migration_coverage_&lt;date&gt;.csv</code>).</p>
<p><strong>Environment Note:</strong> CryptoKit PQC rows require macOS
26+ and an SDK that exposes <code>MLKEM768</code>/<code>MLDSA65</code>.
The script auto-detects and injects <code>-DHAS_APPLE_PQC_SDK</code>
when available.</p>
<p><strong>Baseline Note:</strong> The “Baseline” row in comparative
tables refers to an early prototype without provider abstraction, actor
isolation, or structured timeout handling. This baseline is not shipped
with the current artifact; comparative data is provided for context
only. All primary results (Classic, liboqs PQC, CryptoKit PQC) are
reproducible from the shipped test suite.</p>
<h3 id="b.-security-centric-evaluation">B. Security-Centric
Evaluation</h3>
<h4 id="b.1-failure-mode-robustness">B.1 Failure-Mode Robustness</h4>
<p>This experiment validates that the actor-isolated handshake driver
provides deterministic failure semantics without unhandled errors,
double-resume, or sensitive-material leaks. Each fault-injection
scenario is executed under both default and strictPQC policies (n=1000
per policy).</p>
<p><strong>Workloads:</strong> - Timeout (no MessageB delivered) -
Malformed message framing and truncated fields - Invalid signature on
MessageA or MessageB - Out-of-order delivery and duplicate messages</p>
<p><strong>Metrics:</strong> - <code>NoUnexpectedError</code>: 1 if all
injected runs complete without unexpected errors in the harness
(n_unexpected_error = 0) - <code>NoDoubleResume</code>: 1 if
<code>finishOnce</code> never resumes the continuation twice (validated
by unit tests) - <code>ZeroizationVerified</code>: 1 if unit tests
covering timeout/cancel/transport failure pass -
<code>E_handshakeFailed</code>: count of emitted
<code>SecurityEventType.handshakeFailed</code> -
<code>E_cryptoDowngrade</code>: count of emitted
<code>SecurityEventType.cryptoDowngrade</code></p>
<p><strong>TABLE V: Failure-Mode Robustness and
Observability</strong></p>
<p><em>Runs = number of iterations per scenario and policy (n=1000).
Table reports default policy; strictPQC counts are recorded separately
in <code>fault_injection_&lt;date&gt;.csv</code>. All metrics are binary
(1 = pass) except event counts. Data from
<code>Artifacts/fault_injection_&lt;date&gt;.csv</code> produced by
HandshakeFaultInjectionBenchTests; semantic checks from
HandshakeDriverTests.</em></p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 22%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th>Failure Mode</th>
<th>Runs</th>
<th>NoUnexpectedError</th>
<th>NoDoubleResume</th>
<th>ZeroizationVerified</th>
<th>(E_{handshakeFailed})</th>
<th>(E_{cryptoDowngrade})</th>
</tr>
</thead>
<tbody>
<tr>
<td>Out-of-order</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>Duplicate</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>Drop</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
<tr>
<td>Delay within timeout</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>Delay exceed timeout</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
<tr>
<td>Corrupt header</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
<tr>
<td>Corrupt payload</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
<tr>
<td>Wrong signature</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
<tr>
<td>Concurrent cancel</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
<tr>
<td>Concurrent timeout</td>
<td>1000</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1000</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Downgrade events are quantified separately in the policy bench (Fig.
6) to avoid conflating fallback behavior with transport corruption
scenarios.</p>
<figure>
<embed src="figures/fig_policy_downgrade.pdf" />
<figcaption aria-hidden="true">Fig. 6. Policy guard enforces strictPQC:
fallback events per 1000 runs (95% CI), macOS 26.x, N=1000 per
policy.</figcaption>
</figure>
<p>Fig. 6 is generated from
<code>policy_downgrade_&lt;date&gt;.csv</code> and demonstrates that
strictPQC never emits fallback events even under forced PQC-unavailable
errors; default policy shows non-zero downgrade events.</p>
<figure>
<img src="figures/fig_downgrade_matrix.png" alt="Fig. 7. Downgrade decision matrix (policy x error) with explicit allow/deny semantics, macOS 26.x." />
<figcaption aria-hidden="true">Fig. 7. Downgrade decision matrix (policy
x error) with explicit allow/deny semantics, macOS 26.x.</figcaption>
</figure>
<p>Fig. 7 encodes the explicit downgrade whitelist/blacklist: only
PQC-unavailability and suite-selection errors may fallback under default
policy; strictPQC denies all fallback edges.</p>
<figure>
<img src="figures/fig_failure_histogram.png" alt="Fig. 8. Failure-mode histogram of security events, macOS 26.x, N=1000 per scenario." />
<figcaption aria-hidden="true">Fig. 8. Failure-mode histogram of
security events, macOS 26.x, N=1000 per scenario.</figcaption>
</figure>
<p>Fig. 8 combines fault-injection counts with the downgrade-acceptance
event from the policy bench to visualize observability of failures and
downgrades.</p>
<h4 id="b.2-comparison-with-baseline">B.2 Comparison with Baseline</h4>
<p>The baseline implementation lacks: 1. Provider abstraction
(hard-coded X25519/Ed25519) 2. Actor-based state machine (uses manual
locks) 3. Structured timeout handling (uses DispatchQueue.asyncAfter) 4.
Zeroization guarantees (uses standard Swift Data)</p>
<p>Under fault injection, the baseline exhibited instability under
concurrent cancellation/timeouts and lacked deterministic zeroization on
failure paths. We treat these observations as qualitative context rather
than quantitative evidence and do not include baseline numbers in the
primary evaluation tables.</p>
<p>The actor-based design eliminates these race conditions with
negligible additional latency per handshake.</p>
<h4 id="b.3-property-oriented-testing">B.3 Property-Oriented
Testing</h4>
<p>Correctness properties are validated using property-oriented tests
that cover parameter matrices (e.g., multiple timeout configurations,
malformed framing variants, replay/downgrade scenarios) and repeated
trials for timing-sensitive behaviors. Where randomized vectors are used
(e.g., KEM-DEM round-trip), the tests fix a reproducible seed and report
the number of trials executed.</p>
<p><strong>Property 1 (Round-Trip):</strong> For any valid plaintext and
key pair, <code>kemDemOpen(kemDemSeal(plaintext)) == plaintext</code>.
Validated across all three provider implementations with 100 random
plaintexts (seed: 0xDEADBEEF).</p>
<p><strong>Property 2 (Signature Verification):</strong> For any data
and key pair,
<code>verify(data, sign(data, privateKey), publicKey) == true</code>.
Validated with 100 random payloads per provider.</p>
<p><strong>Property 3 (Zeroization):</strong> For any
<code>SecureBytes</code> instance, deallocation triggers the wiping
function. Validated via injectable <code>wipingFunction</code> that
increments a counter; test asserts counter equals allocation count.</p>
<p><strong>Property 4 (State Machine):</strong> No sequence of valid
inputs causes double-resume of a continuation. Validated via concurrent
cancellation/timeout/message-arrival stress tests (500 iterations).</p>
<h4 id="b.4-ml-dsa-key-lifecycle-validation">B.4 ML-DSA Key Lifecycle
Validation</h4>
<p>This experiment validates the ML-DSA-65 key generation, storage, and
sign-verify round-trip correctness as implemented in
<code>DeviceIdentityKeyManager</code>.</p>
<p><strong>TABLE VI: ML-DSA-65 Key Sizes (FIPS 204
Compliance)</strong></p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Expected (FIPS 204)</th>
<th>Measured</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Public Key</td>
<td>1952 bytes</td>
<td>1952 bytes</td>
<td>OK</td>
</tr>
<tr>
<td>Secret Key</td>
<td>4032 bytes</td>
<td>4032 bytes</td>
<td>OK</td>
</tr>
<tr>
<td>Signature</td>
<td>3309 bytes</td>
<td>3309 bytes</td>
<td>OK</td>
</tr>
</tbody>
</table>
<p><strong>Property 5 (ML-DSA Sign-Verify Round Trip):</strong> For any
message (m) and ML-DSA-65 key pair ((pk, sk)),
<code>verify(m, sign(m, sk), pk) == true</code>. Validated with 100
random messages of varying lengths (1–10,000 bytes) per trial.</p>
<p><strong>Property 6 (ML-DSA Signature Integrity):</strong> Modifying
any byte of the message or signature causes verification to fail.
Validated with 50 random modifications each for message tampering and
signature tampering.</p>
<p><strong>Property 7 (ML-DSA Key Independence):</strong> ML-DSA-65 keys
are independent from Ed25519 keys; using the wrong public key for
verification always fails. Validated with 50 cross-key verification
attempts.</p>
<p><strong>TABLE VII: ML-DSA-65 Property Test Results</strong></p>
<p><em>All tests executed via DeviceIdentityKeyManagerMLDSATests. N =
number of iterations per property.</em></p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 9%" />
<col style="width: 35%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th>Property</th>
<th>N</th>
<th>Pass Rate</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sign-Verify Round Trip</td>
<td>100</td>
<td>100%</td>
<td>Random messages 1–10,000 bytes</td>
</tr>
<tr>
<td>Modified Message -&gt; Fail</td>
<td>50</td>
<td>100%</td>
<td>Single byte XOR modification</td>
</tr>
<tr>
<td>Modified Signature -&gt; Fail</td>
<td>50</td>
<td>100%</td>
<td>Single byte XOR modification</td>
</tr>
<tr>
<td>Wrong Public Key -&gt; Fail</td>
<td>50</td>
<td>100%</td>
<td>Cross-keypair verification</td>
</tr>
<tr>
<td>Key Idempotency</td>
<td>2</td>
<td>100%</td>
<td>Multiple calls return same key</td>
</tr>
<tr>
<td>Ed25519/ML-DSA Independence</td>
<td>1</td>
<td>100%</td>
<td>Different algorithms, different keys</td>
</tr>
</tbody>
</table>
<p><strong>DeviceIdentityKeyManager Integration:</strong></p>
<p>The <code>DeviceIdentityKeyManager</code> provides a unified API for
protocol signing keys:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Get ML-DSA-65 signing key handle</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">keyHandle</span> <span class="op">=</span> <span class="cf">try</span> <span class="cf">await</span> manager<span class="op">.</span>getProtocolSigningKeyHandle<span class="op">(</span><span class="cf">for</span><span class="op">:</span> <span class="op">.</span>mlDSA65<span class="op">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Get ML-DSA-65 public key for peer verification</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">publicKey</span> <span class="op">=</span> <span class="cf">try</span> <span class="cf">await</span> manager<span class="op">.</span>getProtocolSigningPublicKey<span class="op">(</span><span class="cf">for</span><span class="op">:</span> <span class="op">.</span>mlDSA65<span class="op">)</span></span></code></pre></div>
<p>Key storage uses Keychain with security attributes: -
<code>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</code>: Keys
accessible after first unlock -
<code>kSecAttrSynchronizable = false</code>: Keys do not sync to iCloud
Keychain</p>
<p>This ensures ML-DSA keys remain device-local and are protected by the
device passcode.</p>
<h4 id="b.5-legacy-fallback-security-precondition-validation">B.5 Legacy
Fallback Security Precondition Validation</h4>
<p>This experiment validates the security preconditions for legacy P-256
signature acceptance during the migration period.</p>
<p><strong>Security Model:</strong></p>
<p>Legacy P-256 signatures are only accepted when one of the following
preconditions is satisfied: 1. <strong>Authenticated Channel:</strong>
The pairing ceremony uses an authenticated out-of-band channel (QR code,
PAKE/PIN, or local pairing) 2. <strong>Existing Trust Record:</strong> A
previously-established TrustRecord contains a
<code>legacyP256PublicKey</code> field</p>
<p>Pure network stranger connections (no authenticated channel, no
existing trust) are rejected to prevent downgrade attacks.</p>
<p><strong>TABLE VIII: Legacy Fallback Precondition Test
Results</strong></p>
<p><em>All tests executed via LegacyFallbackPreconditionTests. Tests
validate Property 7: Legacy Fallback Security Precondition.</em></p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 25%" />
<col style="width: 30%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>Scenario</th>
<th>Precondition</th>
<th>Expected Result</th>
<th>Actual Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pure network stranger</td>
<td>None</td>
<td>Reject</td>
<td>OK Reject</td>
</tr>
<tr>
<td>QR code pairing (verified)</td>
<td>authenticatedChannel</td>
<td>Allow</td>
<td>OK Allow</td>
</tr>
<tr>
<td>PAKE pairing (verified)</td>
<td>authenticatedChannel</td>
<td>Allow</td>
<td>OK Allow</td>
</tr>
<tr>
<td>Existing TrustRecord with legacy key</td>
<td>existingTrustRecord</td>
<td>Allow</td>
<td>OK Allow</td>
</tr>
<tr>
<td>Existing TrustRecord without legacy key</td>
<td>None</td>
<td>Reject</td>
<td>OK Reject</td>
</tr>
<tr>
<td>Network discovery</td>
<td>None</td>
<td>Reject</td>
<td>OK Reject</td>
</tr>
<tr>
<td>Unverified authenticated channel</td>
<td>None</td>
<td>Reject</td>
<td>OK Reject</td>
</tr>
</tbody>
</table>
<p><strong>Property 7 (Legacy Fallback Security Precondition):</strong>
A legacy P-256 signature SHALL only be accepted when a security
precondition is satisfied. Pure network stranger connections SHALL be
rejected. Validated with 12 test cases covering all precondition
combinations.</p>
<p><strong>Coverage Statement:</strong> We define the migration state
space as the Cartesian product of
<code>{authenticatedChannel in {verified, unverified, none}} x {trustRecord in {none, withLegacyKey, withoutLegacyKey}} x {discovery in {network-only, OOB}}</code>.
The 12 scenarios in Table VIII cover all boundary combinations and
security-relevant buckets, yielding 100% coverage of the defined
precondition space. The <code>MigrationCoverageBenchTests</code> harness
records per-scenario outcomes in
<code>Artifacts/migration_coverage_&lt;date&gt;.csv</code>.</p>
<p><strong>Implementation Components:</strong></p>
<ul>
<li><code>LegacyTrustPrecondition</code>: Encapsulates precondition type
and satisfaction status</li>
<li><code>LegacyTrustPreconditionChecker</code>: Evaluates preconditions
based on TrustRecord and PairingContext</li>
<li><code>FirstContactVerifier</code>: Routes verification to legacy or
modern path based on wire algorithm</li>
<li><code>TrustRecordUpdate</code>: Suggests TrustRecord updates with
<code>requiresUpgrade</code> flag for legacy peers</li>
</ul>
<p><strong>Event Emission:</strong></p>
<p>When legacy signatures are accepted, the system emits
<code>legacySignatureAccepted</code> events with full context: -
<code>preconditionType</code>: Which precondition was satisfied -
<code>deviceId</code>: The peer device identifier -
<code>channelType</code>: The authenticated channel type (if
applicable)</p>
<p>This enables audit logging and anomaly detection for legacy fallback
patterns.</p>
<h4 id="b.6-audit-signal-fidelity-event-traces-tpfp">B.6 Audit-Signal
Fidelity (Event Traces + TP/FP)</h4>
<p>This experiment evaluates whether the emitted security events provide
a deterministic, audit-grade explanation of <strong>what
happened</strong>, <strong>why it happened</strong>, and <strong>how the
policy responded</strong>. We treat the fault-injection workloads as
labeled scenarios and check for correct event semantics rather than
classifier performance.</p>
<p><strong>Event Trace Case (Fig. 9):</strong> - <strong>Timeout after
drop (representative):</strong> <code>handshakeFailed</code> is emitted,
and <code>handshakeFallback</code> is blocked due to timeout
blacklist.</p>
<figure>
<img src="figures/fig_event_traces.png" alt="Fig. 9. Audit-signal event trace (representative timeout case) showing attacker action, policy gate, and emitted event." />
<figcaption aria-hidden="true">Fig. 9. Audit-signal event trace
(representative timeout case) showing attacker action, policy gate, and
emitted event.</figcaption>
</figure>
<p><strong>Audit-Signal Fidelity (TP/FP):</strong></p>
<p>We compute a TP/FP summary from the labeled fault-injection runs
(Table V) and the policy downgrade bench (Fig. 6), stratified by policy.
The remaining trace cases are captured in the corresponding TP/FP
classes below.</p>
<p><strong>TABLE XIV: Audit-Signal Fidelity Summary</strong></p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 39%" />
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th>Scenario Class</th>
<th>Expected Signal</th>
<th>N</th>
<th>TP</th>
<th>FP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Drop/Timeout (default)</td>
<td><code>handshakeFailed=1</code>,
<code>handshakeFallback=0</code></td>
<td>3000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>Drop/Timeout (strictPQC)</td>
<td><code>handshakeFailed=1</code>,
<code>handshakeFallback=0</code></td>
<td>3000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>Corrupt/Wrong Sig (default)</td>
<td><code>handshakeFailed=1</code>,
<code>handshakeFallback=0</code></td>
<td>3000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>Corrupt/Wrong Sig (strictPQC)</td>
<td><code>handshakeFailed=1</code>,
<code>handshakeFallback=0</code></td>
<td>3000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>Ordering Benign (default)</td>
<td><code>handshakeFailed=0</code>,
<code>handshakeFallback=0</code></td>
<td>3000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>Ordering Benign (strictPQC)</td>
<td><code>handshakeFailed=0</code>,
<code>handshakeFallback=0</code></td>
<td>3000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>PQC unavailable (default)</td>
<td><code>handshakeFallback=1</code></td>
<td>1000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
<tr>
<td>PQC unavailable (strictPQC)</td>
<td><code>handshakeFallback=0</code></td>
<td>1000</td>
<td>1.00</td>
<td>0.00</td>
</tr>
</tbody>
</table>
<p>This provides a compact, quantifiable view of audit signal
correctness without positioning the system as a detector.</p>
<h4 id="b.7-transcript-tlv-canonical-encoding-validation">B.7 Transcript
TLV Canonical Encoding Validation</h4>
<p>This experiment validates the transcript integrity properties for
both V1 (deterministic) and V2 (TLV canonical) encoding formats. The
versioned transcript system ensures forward compatibility while
maintaining cryptographic binding guarantees.</p>
<p><strong>Transcript Version Design:</strong></p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Encoding</th>
<th>Use Case</th>
<th>Compatibility</th>
</tr>
</thead>
<tbody>
<tr>
<td>V1 (0x01)</td>
<td>Deterministic</td>
<td>Current production</td>
<td>Backward compatible</td>
</tr>
<tr>
<td>V2 (0x02)</td>
<td>TLV Canonical</td>
<td>Future extension</td>
<td>Forward compatible</td>
</tr>
</tbody>
</table>
<p><strong>TLV Format Specification:</strong></p>
<pre><code>┌─────┬────────────────┬───────────────┐
│ Tag │ Length (4B BE) │ Value (N B)   │
│ 1B  │    UInt32      │   Variable    │
└─────┴────────────────┴───────────────┘</code></pre>
<p>Tag ranges: - 0x01-0x0F: Header tags (protocolVersion, role,
domainSeparator, transcriptVersion) - 0x10-0x1F: Negotiation tags
(suiteWireId, capabilities, policy, signatureAlgorithm) - 0x20-0x2F:
Message tags (messageA, messageB, finished) - 0x30-0x3F: Identity tags
(initiatorPublicKey, responderPublicKey, nonces) - 0xF0-0xFF: Extension
tags (reserved)</p>
<p><strong>TABLE IX: Transcript Integrity Property Test
Results</strong></p>
<p><em>All tests executed via TranscriptIntegrityPropertyTests. Tests
validate Property 4: Transcript Integrity (TLV Canonical).</em></p>
<table style="width:100%;">
<colgroup>
<col style="width: 21%" />
<col style="width: 17%" />
<col style="width: 26%" />
<col style="width: 19%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr>
<th>Test Case</th>
<th>Version</th>
<th>Modification</th>
<th>Expected</th>
<th>Actual</th>
</tr>
</thead>
<tbody>
<tr>
<td>Modify MessageB</td>
<td>V1</td>
<td>Content change</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Modify suiteWireId</td>
<td>V2</td>
<td>0x0101-&gt;0x1001</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Same input determinism</td>
<td>V1/V2</td>
<td>None</td>
<td>Hash identical</td>
<td>OK Pass</td>
</tr>
<tr>
<td>V1 vs V2 encoding</td>
<td>Both</td>
<td>Same fields</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Modify nonce</td>
<td>V1/V2</td>
<td>Byte flip</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Modify public key</td>
<td>V1/V2</td>
<td>Byte flip</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Modify signature algorithm</td>
<td>V1/V2</td>
<td>Ed25519-&gt;ML-DSA</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Random byte modification</td>
<td>V1/V2</td>
<td>XOR 0xFF</td>
<td>Hash differs</td>
<td>OK Pass</td>
</tr>
</tbody>
</table>
<p><strong>TABLE X: TLV Encoder/Decoder Validation</strong></p>
<table>
<thead>
<tr>
<th>Test Case</th>
<th>Expected</th>
<th>Actual</th>
</tr>
</thead>
<tbody>
<tr>
<td>Round-trip encoding</td>
<td>All fields preserved</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Length field big-endian</td>
<td>256 = 0x00000100</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Version negotiation (both V1+V2)</td>
<td>Select V2</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Version negotiation (V1 only common)</td>
<td>Select V1</td>
<td>OK Pass</td>
</tr>
<tr>
<td>No common version</td>
<td>Throw error</td>
<td>OK Pass</td>
</tr>
<tr>
<td>Version compatibility check</td>
<td>Strict match</td>
<td>OK Pass</td>
</tr>
</tbody>
</table>
<p><strong>Property 4 (Transcript Integrity):</strong> Modifying ANY
field in the transcript SHALL produce a different hash. This property
holds for both V1 and V2 encodings. Validated with 14 test cases
covering field modifications, determinism, and version negotiation.</p>
<p><strong>Why This Doesn’t Break Legacy Devices:</strong></p>
<ol type="1">
<li><strong>Version Negotiation:</strong> Both parties advertise
supported versions; the highest common version is selected</li>
<li><strong>Fail-Fast on Mismatch:</strong> If versions don’t match,
handshake fails with explicit error code</li>
<li><strong>V1 Default:</strong> Current production uses V1; V2 is
opt-in for future deployments</li>
<li><strong>Transcript Binding:</strong> Both versions bind the same
semantic fields; only encoding differs</li>
</ol>
<p><strong>Implementation Components:</strong></p>
<ul>
<li><code>TranscriptVersion</code>: Enum with V1/V2 cases and version
metadata</li>
<li><code>TranscriptTLVTag</code>: Tag definitions for all transcript
fields</li>
<li><code>TLVEncoder</code>/<code>TLVDecoder</code>: Canonical TLV
encoding/decoding</li>
<li><code>VersionedTranscriptBuilder</code>: Unified builder supporting
both versions</li>
<li><code>TranscriptVersionNegotiator</code>: Version selection and
compatibility checking</li>
</ul>
<h4 id="b.8-regression-test-matrix-validation">B.8 Regression Test
Matrix Validation</h4>
<p>This experiment validates the complete regression test matrix
covering all protocol signature invariants. The matrix ensures that type
system guarantees, fallback behavior, and event emission are correctly
implemented.</p>
<p><strong>TABLE XI: Regression Test Matrix Results</strong></p>
<p><em>All tests executed via ProtocolSignatureRegressionTests. Tests
validate Requirements 12.1-12.6.</em></p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 28%" />
<col style="width: 25%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>Category</th>
<th>Test Case</th>
<th>Expected</th>
<th>Actual</th>
</tr>
</thead>
<tbody>
<tr>
<td>12.1 MessageA Construction</td>
<td>PQC attempt uses ML-DSA-65</td>
<td>sigAAlgorithm == .mlDSA65</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.1 MessageA Construction</td>
<td>PQC suites all isPQCGroup</td>
<td>All suites isPQCGroup == true</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.1 MessageA Construction</td>
<td>Classic attempt uses Ed25519</td>
<td>sigAAlgorithm == .ed25519</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.1 MessageA Construction</td>
<td>Classic suites all ClassicGroup</td>
<td>All suites isPQCGroup == false</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.2 Type System</td>
<td>P-256 not in ProtocolSigningAlgorithm</td>
<td>Conversion returns nil</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.2 Type System</td>
<td>ClassicSignatureProvider has ed25519</td>
<td>algorithm == .ed25519</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.2 Type System</td>
<td>PQCSignatureProvider has mlDSA65</td>
<td>algorithm == .mlDSA65</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.3 Key Mismatch</td>
<td>Wrong key length throws</td>
<td>Error thrown</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.4 Timeout Fallback</td>
<td>Timeout does not trigger fallback</td>
<td>isPQCUnavailableError == false</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.4 Timeout Fallback</td>
<td>signatureVerificationFailed no fallback</td>
<td>isPQCUnavailableError == false</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.4 Timeout Fallback</td>
<td>pqcProviderUnavailable triggers fallback</td>
<td>isPQCUnavailableError == true</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.5 Legacy First Contact</td>
<td>Authenticated channel allows legacy</td>
<td>precondition.isSatisfied == true</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.5 Legacy First Contact</td>
<td>No auth channel rejects legacy</td>
<td>precondition.isSatisfied == false</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.6 Event Emission</td>
<td>handshakeFallback has context</td>
<td>All context fields present</td>
<td>OK Pass</td>
</tr>
<tr>
<td>12.6 Event Emission</td>
<td>legacySignatureAccepted has preconditionType</td>
<td>preconditionType in context</td>
<td>OK Pass</td>
</tr>
</tbody>
</table>
<p><strong>TABLE XII: Final Gate Validation</strong></p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 41%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Gate</th>
<th>Criteria</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compile-Fail Harness</td>
<td>All 3 negative tests fail to compile</td>
<td>OK 3/3 Pass</td>
</tr>
<tr>
<td>P256AsProtocolSignatureProvider</td>
<td>P-256 cannot conform to ProtocolSignatureProvider</td>
<td>OK Compile Error</td>
</tr>
<tr>
<td>CryptoProviderAsSignatureParam</td>
<td>CryptoProvider cannot be passed as signature param</td>
<td>OK Compile Error</td>
</tr>
<tr>
<td>LegacyVerifierHasNoSign</td>
<td>LegacySignatureVerifier has no sign method</td>
<td>OK Compile Error</td>
</tr>
<tr>
<td>Regression Matrix</td>
<td>All 15 regression tests pass</td>
<td>OK 15/15 Pass</td>
</tr>
</tbody>
</table>
<p><strong>Property Summary:</strong></p>
<ul>
<li><strong>Property 1 (Type Exclusion):</strong> P-256 CANNOT be used
as a protocol signature algorithm. Enforced at compile time.</li>
<li><strong>Property 2 (Homogeneity):</strong> PQC attempt uses only PQC
suites; Classic attempt uses only Classic suites.</li>
<li><strong>Property 3 (Fallback Safety):</strong> Only
PQC-unavailability errors trigger fallback; security errors do not.</li>
<li><strong>Property 4 (Legacy Precondition):</strong> Legacy P-256
requires authenticated channel or existing TrustRecord.</li>
<li><strong>Property 5 (Event Audit):</strong> All fallback and legacy
acceptance events include full context for audit.</li>
</ul>
<ol start="4" type="1">
<li><strong>Transcript Binding:</strong> Both versions bind the same
semantic fields; only encoding differs</li>
</ol>
<p><strong>Implementation Components:</strong></p>
<ul>
<li><code>TranscriptVersion</code>: Enum with V1/V2 cases and version
metadata</li>
<li><code>TranscriptTLVTag</code>: Tag definitions for all transcript
fields</li>
<li><code>TLVEncoder</code>/<code>TLVDecoder</code>: Canonical TLV
encoding/decoding</li>
<li><code>VersionedTranscriptBuilder</code>: Unified builder supporting
both versions</li>
<li><code>TranscriptVersionNegotiator</code>: Version selection and
compatibility checking</li>
</ul>
<hr />
<h3 id="c.-cost-centric-evaluation">C. Cost-Centric Evaluation</h3>
<h4 id="c.1-handshake-latency">C.1 Handshake Latency</h4>
<p>This experiment measures the end-to-end time to complete a full
handshake including explicit key confirmation (Finished_R2I/Finished_I2R
exchange). We intentionally isolate cryptographic and state-machine
overhead by using an in-memory loopback transport.</p>
<p><strong>Metrics:</strong> - <code>T_handshake_ms</code>: wall-clock
from <code>recordStart()</code> to verified <code>Finished_I2R</code>
(full handshake completion) as reported by
<code>HandshakeMetricsCollector.handshakeDurationMs</code> -
<code>B_total</code>: total bytes transferred for
<code>MessageA + MessageB + Finished_R2I + Finished_I2R</code>, computed
from serialized lengths observed on the transport - <code>B_msgA</code>,
<code>B_msgB</code>, <code>B_finished</code>: per-message byte totals
from serialized on-wire encoding</p>
<p>Each configuration reports (p50/p95/p99) over (N=1000) iterations
after 10 warmup runs.</p>
<p><strong>TABLE I: Handshake Latency</strong></p>
<p><em>Latency measured from handshake initiation to verified
Finished_I2R. Includes event emission overhead. N=1000 iterations after
10 warmup runs.</em></p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 3%" />
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr>
<th>Configuration</th>
<th>OS Stratum</th>
<th>N</th>
<th>mean (ms)</th>
<th>std (ms)</th>
<th>p50 (ms)</th>
<th>p95 (ms)</th>
<th>p99 (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classic (X25519 + Ed25519)</td>
<td>macOS 26.x</td>
<td>1000</td>
<td>1.648</td>
<td>0.083</td>
<td>1.644</td>
<td>1.794</td>
<td>1.962</td>
</tr>
<tr>
<td>liboqs PQC (ML-KEM-768 + ML-DSA-65)</td>
<td>macOS 26.x</td>
<td>1000</td>
<td>2.526</td>
<td>0.366</td>
<td>2.443</td>
<td>3.241</td>
<td>3.636</td>
</tr>
<tr>
<td>CryptoKit PQC (ML-KEM-768 + ML-DSA-65)</td>
<td>macOS 26.x</td>
<td>1000</td>
<td>10.104</td>
<td>2.672</td>
<td>9.423</td>
<td>15.418</td>
<td>18.940</td>
</tr>
</tbody>
</table>
<p><strong>TABLE I-B: Handshake RTT</strong></p>
<p><em>RTT measured as <code>tB - tA</code> (MessageB receive time minus
MessageA send time). N=1000 iterations after 10 warmup runs.</em></p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 3%" />
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr>
<th>Configuration</th>
<th>OS Stratum</th>
<th>N</th>
<th>mean (ms)</th>
<th>std (ms)</th>
<th>p50 (ms)</th>
<th>p95 (ms)</th>
<th>p99 (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classic (X25519 + Ed25519)</td>
<td>macOS 26.x</td>
<td>1000</td>
<td>0.624</td>
<td>0.073</td>
<td>0.610</td>
<td>0.710</td>
<td>0.966</td>
</tr>
<tr>
<td>liboqs PQC (ML-KEM-768 + ML-DSA-65)</td>
<td>macOS 26.x</td>
<td>1000</td>
<td>1.090</td>
<td>0.262</td>
<td>1.014</td>
<td>1.598</td>
<td>1.974</td>
</tr>
<tr>
<td>CryptoKit PQC (ML-KEM-768 + ML-DSA-65)</td>
<td>macOS 26.x</td>
<td>1000</td>
<td>5.155</td>
<td>1.358</td>
<td>4.925</td>
<td>7.304</td>
<td>9.676</td>
</tr>
</tbody>
</table>
<figure>
<img src="figures/fig_handshake_latency.png"
alt="Fig. 4. Handshake latency percentiles for Classic vs liboqs PQC vs CryptoKit PQC (N=1000)." />
<figcaption aria-hidden="true">Fig. 4. Handshake latency percentiles for
Classic vs liboqs PQC vs CryptoKit PQC (N=1000).</figcaption>
</figure>
<p><strong>TABLE II: Handshake Message Sizes</strong></p>
<p><em>All sizes in bytes. B_finished = 2 x 38 = 76 bytes (Finished_R2I
+ Finished_I2R). B_total = B_msgA + B_msgB + B_finished.</em></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>Configuration</th>
<th>B_msgA (bytes)</th>
<th>B_msgB (bytes)</th>
<th>B_finished (bytes)</th>
<th>B_total (bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classic</td>
<td>337</td>
<td>380</td>
<td>76</td>
<td>793</td>
</tr>
<tr>
<td>liboqs PQC</td>
<td>6560</td>
<td>5493</td>
<td>76</td>
<td>12129</td>
</tr>
<tr>
<td>CryptoKit PQC</td>
<td>6577</td>
<td>5510</td>
<td>76</td>
<td>12163</td>
</tr>
</tbody>
</table>
<p>†X-Wing 是混合套件，当前基准 harness 仅覆盖 pqcOnly/classicOnly
路径，待混合路径纳入 HandshakeBenchmarkTests 后补测；因此主表不包含
projected 行。Table II 中 CryptoKit PQC 与 liboqs PQC
尺寸非常接近，差异来自 provider 元数据与编码细节。X-Wing 的投影估算见
Appendix C。</p>
<figure>
<img src="figures/fig_message_size_breakdown.png"
alt="Fig. 5. Wire-format size breakdown (signature, keyshare, identity fields, framing overhead) for MessageA/MessageB." />
<figcaption aria-hidden="true">Fig. 5. Wire-format size breakdown
(signature, keyshare, identity fields, framing overhead) for
MessageA/MessageB.</figcaption>
</figure>
<p>The size breakdown is generated from
<code>message_sizes_&lt;date&gt;.csv</code>, emitted by
<code>MessageSizeSnapshotTests</code> using deterministic snapshot
messages (minimal capability set), so totals can be slightly smaller
than the end-to-end wire sizes in Table II.</p>
<p>We additionally report a breakdown by dominant contributors (KEM
encapsulation/decapsulation, signature sign/verify, and serialization)
using instrumented timing around provider calls in the benchmark
harness.</p>
<h4 id="c.2-data-plane-throughput-and-cpu-proxy">C.2 Data-Plane
Throughput and CPU Proxy</h4>
<p>Handshake cost is not the only performance concern for remote desktop
and file transfer. This experiment measures cryptographic throughput and
a CPU proxy for the data plane.</p>
<p><strong>Workloads:</strong> - Symmetric AEAD encryption/decryption
using session keys derived by the handshake
(<code>SessionKeys.sendKey</code> / <code>SessionKeys.receiveKey</code>)
- Payload sizes: 1 KiB, 16 KiB, 64 KiB, 1 MiB</p>
<p><strong>Metrics:</strong> - <code>Throughput_MBps</code>: bytes
processed / elapsed time for encrypt+decrypt -
<code>CPU_proxy_ns_per_byte</code>: elapsed ns / bytes processed in a
fixed performance mode</p>
<p><strong>TABLE III: Data-Plane Throughput</strong></p>
<p><em>Throughput measured for symmetric AEAD (AES-256-GCM)
encrypt+decrypt cycle using session keys derived from handshake. Does
not include handshake overhead. N=200 iterations after warmup.</em></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 27%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr>
<th>Configuration</th>
<th>Payload Size</th>
<th>Throughput (MB/s)</th>
<th>CPU Proxy (ns/byte)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classic</td>
<td>1 KiB</td>
<td>404.1</td>
<td>2.36</td>
</tr>
<tr>
<td>Classic</td>
<td>16 KiB</td>
<td>2918.4</td>
<td>0.33</td>
</tr>
<tr>
<td>Classic</td>
<td>64 KiB</td>
<td>3000.0</td>
<td>0.32</td>
</tr>
<tr>
<td>Classic</td>
<td>1 MiB</td>
<td>3755.3</td>
<td>0.25</td>
</tr>
</tbody>
</table>
<h4 id="c.3-provider-selection-overhead">C.3 Provider Selection
Overhead</h4>
<p>This experiment isolates the overhead of capability detection and
provider instantiation. It distinguishes cold-start behavior (first
call, caches empty) from steady-state behavior (hot path, cached
result).</p>
<p><strong>Metrics:</strong> - <code>T_select_cold_us</code>: elapsed
time for
<code>CryptoProviderSelector.shared.bestAvailableProvider</code> on
first call after <code>clearCache()</code> -
<code>T_select_hot_us</code>: elapsed time for subsequent calls with
warm caches</p>
<p><strong>TABLE IV: Provider Selection Overhead</strong></p>
<p><em>Time measured using ContinuousClock. Cold = after clearCache();
Hot = cached path. N=200 iterations.</em></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>Scenario</th>
<th>p50 (us)</th>
<th>p95 (us)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cold start</td>
<td>0.584</td>
<td>0.750</td>
<td>Includes OS/version checks and API probing/self-test</td>
</tr>
<tr>
<td>Hot path</td>
<td>0.167</td>
<td>0.209</td>
<td>Cached selection</td>
</tr>
<tr>
<td>PQC unavailable fallback</td>
<td>2.542</td>
<td>5.125</td>
<td>Provider tier downgrade</td>
</tr>
<tr>
<td>Self-test failure recovery</td>
<td>2.500</td>
<td>5.833</td>
<td>Native PQC probe fails, fallback engages</td>
</tr>
</tbody>
</table>
<h2 id="viii.-limitations-and-future-work">VIII. LIMITATIONS AND FUTURE
WORK</h2>
<h3 id="a.-current-limitations">A. Current Limitations</h3>
<ol type="1">
<li><p><strong>iOS liboqs Bundling:</strong> The current implementation
does not bundle liboqs for iOS, limiting PQC availability to iOS 26+
devices.</p></li>
<li><p><strong>X-Wing Hybrid KEM:</strong> We have reserved wire-format
identifiers for X-Wing hybrid KEM (wireId 0x0001, combining X25519 +
ML-KEM-768). CryptoKit on Apple 26+ exposes HPKE cipher suites including
X-Wing (ML-KEM-768 with X25519), enabling a standards-aligned
replacement for our compatibility envelope [14]. Our current
implementation uses pure ML-KEM-768 (wireId 0x0101); the X-Wing provider
mapping is planned for a future release once we complete integration
testing with CryptoKit’s PQ-HPKE API.</p></li>
<li><p><strong>Key Rotation:</strong> Session key rotation during
long-lived connections is not addressed in the current design.</p></li>
<li><p><strong>Cross-Platform Interoperability:</strong> The wire format
is documented but interoperability with non-Apple platforms requires
additional validation.</p></li>
</ol>
<h3 id="b.-future-directions">B. Future Directions</h3>
<ol type="1">
<li><p><strong>Android PQC Integration:</strong> Extend the
CryptoProvider architecture to support Android’s BouncyCastle PQC
implementations.</p></li>
<li><p><strong>Formal Verification:</strong> Apply model checking to the
handshake state machine to prove absence of deadlocks and race
conditions.</p></li>
<li><p><strong>Performance Optimization:</strong> Profile ML-KEM-768
encapsulation latency and explore hardware acceleration
opportunities.</p></li>
<li><p><strong>Certificate-Based Identity:</strong> Integrate with
device certificates for enterprise deployment scenarios.</p></li>
</ol>
<hr />
<h2 id="ix.-conclusion">IX. CONCLUSION</h2>
<p>SkyBridge Compass demonstrates that cryptographic agility and
post-quantum readiness can be achieved in production P2P systems without
sacrificing API stability or operational transparency. The layered
CryptoProvider architecture enables seamless adoption of new primitives
as platforms evolve, while the actor-isolated handshake state machine
provides strong guarantees against concurrency bugs and sensitive
material exposure.</p>
<p>Our implementation on Apple platforms shows that native PQC APIs can
be integrated with minimal overhead when available, with graceful
fallback to library-based or classic implementations on older systems.
The structured security event model ensures that all cryptographic
decisions are auditable, supporting both real-time monitoring and
post-incident analysis.</p>
<p>As post-quantum cryptography transitions from standardization to
deployment, systems like SkyBridge Compass provide a practical template
for managing this transition while maintaining security and usability
across heterogeneous device fleets.</p>
<hr />
<h2 id="references">REFERENCES</h2>
<p>[1] Apple Inc., “CryptoKit Framework,” Apple Developer Documentation,
2025. [Online]. Available:
https://developer.apple.com/documentation/cryptokit. Accessed:
Dec. 2025.</p>
<p>[2] Bluetooth SIG, “Bluetooth Core Specification v5.4,” 2023.</p>
<p>[3] Apple Inc., “Continuity,” Apple Platform Security Guide,
2024.</p>
<p>[4] T. Taubert and C. A. Wood, “SPAKE2+, an Augmented PAKE,” RFC
9383, IETF, Sept. 2023. [Online]. Available:
https://datatracker.ietf.org/doc/rfc9383/</p>
<p>[5] D. McGrew, “Achieving Crypto Agility,” in Proc. RSA Conference,
2019.</p>
<p>[6] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version
1.3,” RFC 8446, IETF, 2018.</p>
<p>[7] E. Barker and A. Roginsky, “Transitioning the Use of
Cryptographic Algorithms and Key Lengths,” NIST SP 800-131A Rev. 2,
2019.</p>
<p>[8] NIST, “Post-Quantum Cryptography Standardization,” 2024.
[Online]. Available:
https://csrc.nist.gov/projects/post-quantum-cryptography. Accessed:
Dec. 2025.</p>
<p>[9] Signal Foundation, “PQXDH Key Agreement Protocol,” Signal
Technical Documentation, 2023.</p>
<p>[10] Cloudflare, “Post-Quantum Cryptography Goes GA,” Cloudflare
Blog, Sept. 29, 2023. [Online]. Available:
https://blog.cloudflare.com/post-quantum-cryptography-ga/. Accessed:
Dec. 2025.</p>
<p>[11] D. Beyer et al., “Software Model Checking,” in Handbook of Model
Checking, Springer, 2018.</p>
<p>[12] Apple Inc., “Swift Concurrency,” The Swift Programming Language,
2024.</p>
<p>[13] R. Barnes, K. Bhargavan, B. Lipp, and C. Wood, “Hybrid Public
Key Encryption,” RFC 9180, IETF, Feb. 2022. [Online]. Available:
https://datatracker.ietf.org/doc/rfc9180/</p>
<p>[14] Apple Inc., “Get ahead with quantum-secure cryptography,” WWDC
2025 Session 314, June 2025. [Online]. Available:
https://developer.apple.com/videos/play/wwdc2025/314/. Accessed:
Dec. 2025.</p>
<p>[15] NIST, “Module-Lattice-Based Key-Encapsulation Mechanism
Standard,” FIPS 203, Aug. 2024. [Online]. Available:
https://csrc.nist.gov/pubs/fips/203/final</p>
<p>[16] NIST, “Module-Lattice-Based Digital Signature Standard,” FIPS
204, Aug. 2024. [Online]. Available:
https://csrc.nist.gov/pubs/fips/204/final</p>
<p>[17] M. Barbosa, D. Connolly, J. Duarte, A. Kaiser, P. Schwabe, K.
Varber, and B. Westerbaan, “X-Wing: The Hybrid KEM You’ve Been Looking
For,” IETF Internet-Draft, 2024. [Online]. Available:
https://datatracker.ietf.org/doc/draft-connolly-cfrg-xwing-kem/</p>
<p>[18] J. Iyengar and M. Thomson, “QUIC: A UDP-Based Multiplexed and
Secure Transport,” RFC 9000, IETF, 2021. [Online]. Available:
https://datatracker.ietf.org/doc/rfc9000/</p>
<p>[19] T. Perrin, “The Noise Protocol Framework,” 2018. [Online].
Available: https://noiseprotocol.org/noise.pdf</p>
<hr />
<h2 id="appendix-a-key-size-reference">APPENDIX A: KEY SIZE
REFERENCE</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 23%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th>Algorithm</th>
<th>Public Key</th>
<th>Private Key (Apple)¹</th>
<th>Private Key (FIPS)</th>
<th>Ciphertext/Signature</th>
</tr>
</thead>
<tbody>
<tr>
<td>ML-KEM-768</td>
<td>1184 B</td>
<td>96 B</td>
<td>2400 B</td>
<td>1088 B</td>
</tr>
<tr>
<td>ML-KEM-1024</td>
<td>1568 B</td>
<td>128 B²</td>
<td>3168 B</td>
<td>1568 B</td>
</tr>
<tr>
<td>ML-DSA-65</td>
<td>1952 B</td>
<td>64 B</td>
<td>4032 B</td>
<td>~3309 B</td>
</tr>
<tr>
<td>ML-DSA-87</td>
<td>2592 B</td>
<td>96 B²</td>
<td>4896 B</td>
<td>~4627 B</td>
</tr>
<tr>
<td>X25519</td>
<td>32 B</td>
<td>32 B</td>
<td>-</td>
<td>32 B</td>
</tr>
<tr>
<td>Ed25519</td>
<td>32 B</td>
<td>32 B</td>
<td>-</td>
<td>64 B</td>
</tr>
</tbody>
</table>
<p>¹ Apple CryptoKit uses <code>integrityCheckedRepresentation</code>
for private key serialization, which employs a seed-based compact
format. This is more storage-efficient than the FIPS 203/204 expanded
format. Public keys use <code>rawRepresentation</code> which matches
FIPS standard sizes. Measurements performed on macOS 26.0 (Tahoe)
SDK.</p>
<p>² Estimated based on seed-based representation pattern; actual sizes
may vary.</p>
<hr />
<h2 id="appendix-b-security-event-types">APPENDIX B: SECURITY EVENT
TYPES</h2>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 32%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr>
<th>Event Type</th>
<th>Severity</th>
<th>Trigger</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cryptoProviderSelected</code></td>
<td>info/warning</td>
<td>Provider factory selection</td>
</tr>
<tr>
<td><code>cryptoDowngrade</code></td>
<td>warning</td>
<td>PQC to classic fallback</td>
</tr>
<tr>
<td><code>handshakeFailed</code></td>
<td>warning</td>
<td>Any handshake failure</td>
</tr>
<tr>
<td><code>signatureVerificationFailed</code></td>
<td>high</td>
<td>Invalid peer protoSignature</td>
</tr>
<tr>
<td><code>secureEnclaveVerificationFailed</code></td>
<td>warning</td>
<td>Invalid secureEnclaveSignature</td>
</tr>
<tr>
<td><code>identityMismatch</code></td>
<td>high</td>
<td>identityPubKey does not match pinned key</td>
</tr>
<tr>
<td><code>contextZeroized</code></td>
<td>info</td>
<td>Sensitive material cleared</td>
</tr>
<tr>
<td><code>suiteNegotiationFailed</code></td>
<td>warning</td>
<td>No common suite found</td>
</tr>
<tr>
<td><code>unexpectedStateTransition</code></td>
<td>high</td>
<td>Actor reentrancy detected</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="appendix-c-x-wing-wire-size-projection">APPENDIX C: X-WING
WIRE-SIZE PROJECTION</h2>
<p>We exclude X-Wing from the main tables because the benchmark harness
currently exercises only <code>pqcOnly</code>/<code>classicOnly</code>
paths. For a conservative wire-size estimate, we start from Table II
(pure ML-KEM-768 + ML-DSA-65) and adjust only the KEM keyshare
lengths:</p>
<pre><code>DeltaKEM = (X-Wing share 1216 B) - (ML-KEM-768 share 1088 B) = +128 B

B_msgA(xwing) approx 6556 + 128 = 6684 B
B_msgB(xwing) approx 5489 + 128 = 5617 B
B_total(xwing) approx 6684 + 5617 + 76 = 12,377 B</code></pre>
<p>This yields an estimated total wire size of <strong>approx12.4
KB</strong> for the full handshake, assuming the same signature/identity
sizes (ML-DSA-65) as the PQC-only suites. If X-Wing is integrated via
native CryptoKit HPKE (removing the compatibility envelope
header/nonce/tag overhead), the total is expected to drop slightly; we
will report the measured figure once the hybrid path is benchmarked.</p>
<hr />
<h2 id="acknowledgment">ACKNOWLEDGMENT</h2>
<p>This work received no external funding. The system design,
implementation, and all experiments were conducted by the author.
Portions of background data and platform/security references used in the
evaluation and discussion are derived from publicly available materials
published by Apple and Google, as cited throughout the paper. The views
and conclusions are those of the author and do not necessarily reflect
those of Apple or Google.</p>
<h2 id="funding">FUNDING</h2>
<p>This research did not receive any specific grant from funding
agencies in the public, commercial, or not-for-profit sectors.</p>
<h2 id="author-contributions">AUTHOR CONTRIBUTIONS</h2>
<p>Single-author paper. The author performed conceptualization, protocol
and system design, implementation, experimentation, data analysis, and
manuscript writing.</p>
<h2 id="data-and-artifact-availability">DATA AND ARTIFACT
AVAILABILITY</h2>
<p>The artifact package includes the implementation, reproducible test
harnesses, and scripts that regenerate primary figures and tables.
Running the provided test filters produces CSV outputs under Artifacts/
(e.g., handshake latency/RTT, wire sizes, fault injection outcomes, and
downgrade-policy traces), and the included scripts derive aggregate
plots and audit-signal fidelity summaries from these traces.</p>
<h2 id="conflict-of-interest">CONFLICT OF INTEREST</h2>
<p>The author declares no competing interests.</p>
</body>
</html>
