//
// PQCProbeTests.swift
// SkyBridgeCoreTests
//
// Apple PQC Implementation - Property-Based Tests
// Requirements: 1.1, 1.3, 1.4, 2.1, 2.2, 2.3, 2.4, 2.5, 3.2, 3.3, 3.5
//
// 此文件包含 Apple CryptoKit PQC API 的属性测试。
// 使用 HAS_APPLE_PQC_SDK 编译标志控制编译。
//

import XCTest
@testable import SkyBridgeCore

// MARK: - PQC Property Tests

#if HAS_APPLE_PQC_SDK
import CryptoKit

/// Apple PQC 属性测试
/// 验证 ML-KEM-768 和 ML-DSA-65 的正确性属性
@available(macOS 26.0, *)
final class PQCProbeTests: XCTestCase {
    
 /// 属性测试迭代次数
    private let propertyTestIterations = 100
    
 // MARK: - Property 1: ML-KEM key generation produces correct sizes
    
 /// **Feature: apple-pqc-implementation, Property 1: ML-KEM key generation produces correct sizes**
 /// **Validates: Requirements 1.1**
 ///
 /// *For any* ML-KEM-768 key pair generated by ApplePQCProvider,
 /// the public key should be exactly 1184 bytes and the private key should be exactly 2400 bytes.
    func testProperty1_MLKEMKeyGenerationProducesCorrectSizes() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for _ in 0..<propertyTestIterations {
            let keyPair = try await provider.generateKeyPair(for: .keyExchange)
            
            XCTAssertEqual(
                keyPair.publicKey.bytes.count,
                ApplePQCCryptoProvider.mlkem768PublicKeySize,
                "ML-KEM-768 public key should be exactly \(ApplePQCCryptoProvider.mlkem768PublicKeySize) bytes"
            )
            
            XCTAssertEqual(
                keyPair.privateKey.bytes.count,
                ApplePQCCryptoProvider.mlkem768PrivateKeySize,
                "ML-KEM-768 private key should be exactly \(ApplePQCCryptoProvider.mlkem768PrivateKeySize) bytes"
            )
        }
    }
    
 // MARK: - Property 2: ML-KEM encapsulation/decapsulation round-trip
    
 /// **Feature: apple-pqc-implementation, Property 2: ML-KEM encapsulation/decapsulation round-trip**
 /// **Validates: Requirements 1.3**
 ///
 /// *For any* ML-KEM-768 key pair and encapsulation operation,
 /// decapsulating the ciphertext with the corresponding private key
 /// should recover the identical shared secret.
    func testProperty2_MLKEMEncapsulationDecapsulationRoundTrip() async throws {
        for _ in 0..<propertyTestIterations {
 // Generate a fresh key pair
            let privateKey = try MLKEM768.PrivateKey()
            let publicKey = privateKey.publicKey
            
 // Encapsulate
            let encapsulationResult = try publicKey.encapsulate()
            let sharedSecret1 = encapsulationResult.sharedSecret
            let encapsulatedKey = encapsulationResult.encapsulated
            
 // Verify ciphertext size
            XCTAssertEqual(
                encapsulatedKey.count,
                ApplePQCCryptoProvider.mlkem768CiphertextSize,
                "ML-KEM-768 ciphertext should be exactly \(ApplePQCCryptoProvider.mlkem768CiphertextSize) bytes"
            )
            
 // Decapsulate
            let sharedSecret2 = try privateKey.decapsulate(encapsulatedKey)
            
 // Verify round-trip: shared secrets must be identical
            XCTAssertEqual(
                sharedSecret1,
                sharedSecret2,
                "Encapsulated and decapsulated shared secrets must be identical"
            )
        }
    }
    
 // MARK: - Property 3: ML-KEM key serialization round-trip
    
 /// **Feature: apple-pqc-implementation, Property 3: ML-KEM key serialization round-trip**
 /// **Validates: Requirements 1.4**
 ///
 /// *For any* ML-KEM-768 key, serializing to rawRepresentation and deserializing
 /// should produce a functionally equivalent key that generates the same public key.
    func testProperty3_MLKEMKeySerializationRoundTrip() async throws {
        for _ in 0..<propertyTestIterations {
 // Generate original key pair
            let originalPrivateKey = try MLKEM768.PrivateKey()
            let originalPublicKey = originalPrivateKey.publicKey
            
 // Serialize private key
            let privateKeyData = originalPrivateKey.integrityCheckedRepresentation
            
 // Deserialize private key
            let restoredPrivateKey = try MLKEM768.PrivateKey(integrityCheckedRepresentation: privateKeyData)
            let restoredPublicKey = restoredPrivateKey.publicKey
            
 // Verify public keys match (proves private key was correctly restored)
            XCTAssertEqual(
                originalPublicKey.rawRepresentation,
                restoredPublicKey.rawRepresentation,
                "Restored private key should produce the same public key"
            )
            
 // Serialize and restore public key
            let publicKeyData = originalPublicKey.rawRepresentation
            let restoredPublicKey2 = try MLKEM768.PublicKey(rawRepresentation: publicKeyData)
            
            XCTAssertEqual(
                originalPublicKey.rawRepresentation,
                restoredPublicKey2.rawRepresentation,
                "Public key should survive serialization round-trip"
            )
        }
    }
    
 // MARK: - Property 8: HPKE seal/open round-trip
    
 /// **Feature: apple-pqc-implementation, Property 8: HPKE seal/open round-trip**
 /// **Validates: Requirements 3.2, 3.3**
 ///
 /// *For any* plaintext, key pair, and info parameter,
 /// sealing with hpkeSeal and opening with hpkeOpen should recover the original plaintext.
    func testProperty8_HPKESealOpenRoundTrip() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for i in 0..<propertyTestIterations {
 // Generate random plaintext (1 to 1024 bytes)
            let plaintextSize = Int.random(in: 1...1024)
            var plaintext = Data(count: plaintextSize)
            _ = plaintext.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, plaintextSize, $0.baseAddress!) }
            
 // Generate random info parameter (0 to 64 bytes)
            let infoSize = Int.random(in: 0...64)
            var info = Data(count: infoSize)
            if infoSize > 0 {
                _ = info.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, infoSize, $0.baseAddress!) }
            }
            
 // Generate key pair
            let keyPair = try await provider.generateKeyPair(for: .keyExchange)
            
 // Seal
            let sealedBox = try await provider.hpkeSeal(
                plaintext: plaintext,
                recipientPublicKey: keyPair.publicKey.bytes,
                info: info
            )
            
 // Open
            let decrypted = try await provider.hpkeOpen(
                sealedBox: sealedBox,
                privateKey: keyPair.privateKey.bytes,
                info: info
            )
            
 // Verify round-trip
            XCTAssertEqual(
                plaintext,
                decrypted,
                "HPKE round-trip failed at iteration \(i): plaintext size=\(plaintextSize), info size=\(infoSize)"
            )
        }
    }
    
 // MARK: - Property 4: ML-DSA key generation produces correct sizes
    
 /// **Feature: apple-pqc-implementation, Property 4: ML-DSA key generation produces correct sizes**
 /// **Validates: Requirements 2.1**
 ///
 /// *For any* ML-DSA-65 key pair generated by ApplePQCProvider,
 /// the public key should be exactly 1952 bytes and the private key should be exactly 64 bytes (seed format).
    func testProperty4_MLDSAKeyGenerationProducesCorrectSizes() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for _ in 0..<propertyTestIterations {
            let keyPair = try await provider.generateKeyPair(for: .signing)
            
            XCTAssertEqual(
                keyPair.publicKey.bytes.count,
                ApplePQCCryptoProvider.mldsa65PublicKeySize,
                "ML-DSA-65 public key should be exactly \(ApplePQCCryptoProvider.mldsa65PublicKeySize) bytes"
            )
            
            XCTAssertEqual(
                keyPair.privateKey.bytes.count,
                ApplePQCCryptoProvider.mldsa65PrivateKeySize,
                "ML-DSA-65 private key should be exactly \(ApplePQCCryptoProvider.mldsa65PrivateKeySize) bytes"
            )
        }
    }
    
 // MARK: - Property 5: ML-DSA sign/verify round-trip
    
 /// **Feature: apple-pqc-implementation, Property 5: ML-DSA sign/verify round-trip**
 /// **Validates: Requirements 2.2, 2.3**
 ///
 /// *For any* data and ML-DSA-65 key pair, signing the data with the private key
 /// and verifying with the corresponding public key should return true.
    func testProperty5_MLDSASignVerifyRoundTrip() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for i in 0..<propertyTestIterations {
 // Generate random data (1 to 1024 bytes)
            let dataSize = Int.random(in: 1...1024)
            var data = Data(count: dataSize)
            _ = data.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, dataSize, $0.baseAddress!) }
            
 // Generate key pair
            let keyPair = try await provider.generateKeyPair(for: .signing)
            
 // Sign
            let signature = try await provider.sign(
                data: data,
                using: .softwareKey(keyPair.privateKey.bytes)
            )
            
 // Verify
            let isValid = try await provider.verify(
                data: data,
                signature: signature,
                publicKey: keyPair.publicKey.bytes
            )
            
            XCTAssertTrue(
                isValid,
                "ML-DSA sign/verify round-trip failed at iteration \(i): data size=\(dataSize)"
            )
        }
    }
    
 // MARK: - Property 6: ML-DSA key serialization round-trip
    
 /// **Feature: apple-pqc-implementation, Property 6: ML-DSA key serialization round-trip**
 /// **Validates: Requirements 2.5**
 ///
 /// *For any* ML-DSA-65 key, serializing to rawRepresentation and deserializing
 /// should produce a functionally equivalent key.
    func testProperty6_MLDSAKeySerializationRoundTrip() async throws {
        for _ in 0..<propertyTestIterations {
 // Generate original key pair
            let originalPrivateKey = try MLDSA65.PrivateKey()
            let originalPublicKey = originalPrivateKey.publicKey
            
 // Serialize private key
            let privateKeyData = originalPrivateKey.integrityCheckedRepresentation
            
 // Deserialize private key
            let restoredPrivateKey = try MLDSA65.PrivateKey(integrityCheckedRepresentation: privateKeyData)
            let restoredPublicKey = restoredPrivateKey.publicKey
            
 // Verify public keys match (proves private key was correctly restored)
            XCTAssertEqual(
                originalPublicKey.rawRepresentation,
                restoredPublicKey.rawRepresentation,
                "Restored private key should produce the same public key"
            )
            
 // Serialize and restore public key
            let publicKeyData = originalPublicKey.rawRepresentation
            let restoredPublicKey2 = try MLDSA65.PublicKey(rawRepresentation: publicKeyData)
            
            XCTAssertEqual(
                originalPublicKey.rawRepresentation,
                restoredPublicKey2.rawRepresentation,
                "Public key should survive serialization round-trip"
            )
        }
    }
    
 // MARK: - Property 7: ML-DSA tampered signature rejection
    
 /// **Feature: apple-pqc-implementation, Property 7: ML-DSA tampered signature rejection**
 /// **Validates: Requirements 2.4**
 ///
 /// *For any* valid ML-DSA-65 signature, if any bit is flipped, verification should return false.
    func testProperty7_MLDSATamperedSignatureRejection() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for i in 0..<propertyTestIterations {
 // Generate random data (1 to 256 bytes)
            let dataSize = Int.random(in: 1...256)
            var data = Data(count: dataSize)
            _ = data.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, dataSize, $0.baseAddress!) }
            
 // Generate key pair
            let keyPair = try await provider.generateKeyPair(for: .signing)
            
 // Sign
            let signature = try await provider.sign(
                data: data,
                using: .softwareKey(keyPair.privateKey.bytes)
            )
            
 // Tamper with signature (flip a random bit)
            var tamperedSignature = signature
            guard !tamperedSignature.isEmpty else {
                XCTFail("Signature should not be empty")
                continue
            }
            let byteIndex = Int.random(in: 0..<tamperedSignature.count)
            let bitIndex = UInt8.random(in: 0..<8)
            tamperedSignature[byteIndex] ^= (1 << bitIndex)
            
 // Verify tampered signature should fail
            let isValid = try await provider.verify(
                data: data,
                signature: tamperedSignature,
                publicKey: keyPair.publicKey.bytes
            )
            
            XCTAssertFalse(
                isValid,
                "Tampered signature should fail verification at iteration \(i)"
            )
        }
    }
    
 // MARK: - ML-KEM API Probe Tests
    
 /// 探测 ML-KEM-768 API
    func testMLKEM768APIProbe() throws {
 // 密钥生成
        let privateKey = try MLKEM768.PrivateKey()
        let publicKey = privateKey.publicKey
        
 // 验证密钥长度
 // Note: Apple uses seed-based compact representation for private keys
        XCTAssertEqual(publicKey.rawRepresentation.count, 1184,
                       "ML-KEM-768 public key should be 1184 bytes")
        XCTAssertEqual(privateKey.integrityCheckedRepresentation.count, 96,
                       "ML-KEM-768 private key (seed format) should be 96 bytes")
        
 // 封装/解封装
        let encapsulationResult = try publicKey.encapsulate()
        XCTAssertEqual(encapsulationResult.encapsulated.count, 1088,
                       "ML-KEM-768 ciphertext should be 1088 bytes")
        
        let decapsulated = try privateKey.decapsulate(encapsulationResult.encapsulated)
        XCTAssertEqual(encapsulationResult.sharedSecret, decapsulated,
                       "Encapsulated and decapsulated secrets should match")
    }
    
 // MARK: - ML-DSA API Probe Tests ( 3 will implement)
    
 /// 探测 ML-DSA-65 API
    func testMLDSA65APIProbe() throws {
 // 密钥生成
        let privateKey = try MLDSA65.PrivateKey()
        let publicKey = privateKey.publicKey
        
 // 验证密钥长度
 // Note: Apple uses seed-based compact representation for private keys
        XCTAssertEqual(publicKey.rawRepresentation.count, 1952,
                       "ML-DSA-65 public key should be 1952 bytes")
        XCTAssertEqual(privateKey.integrityCheckedRepresentation.count, 64,
                       "ML-DSA-65 private key (seed format) should be 64 bytes")
        
 // 签名/验签
        let message = Data("Test message for ML-DSA-65".utf8)
        let signature = try privateKey.signature(for: message)
        XCTAssertTrue(publicKey.isValidSignature(signature, for: message),
                      "Signature should verify correctly")
        
 // 篡改签名应失败
        var tamperedSignature = signature
        if !tamperedSignature.isEmpty {
            tamperedSignature[0] ^= 0xFF
        }
        XCTAssertFalse(publicKey.isValidSignature(tamperedSignature, for: message),
                       "Tampered signature should fail verification")
    }
    
 // MARK: - Key Serialization Probe
    
 /// 探测密钥序列化 API
    func testKeySerializationProbe() throws {
 // ML-KEM-768 序列化
        let kemPrivateKey = try MLKEM768.PrivateKey()
        let kemRawData = kemPrivateKey.integrityCheckedRepresentation
        let restoredKemKey = try MLKEM768.PrivateKey(integrityCheckedRepresentation: kemRawData)
        XCTAssertEqual(kemPrivateKey.publicKey.rawRepresentation,
                       restoredKemKey.publicKey.rawRepresentation,
                       "ML-KEM-768 key should survive round-trip")
        
 // ML-DSA-65 序列化
        let dsaPrivateKey = try MLDSA65.PrivateKey()
        let dsaRawData = dsaPrivateKey.integrityCheckedRepresentation
        let restoredDsaKey = try MLDSA65.PrivateKey(integrityCheckedRepresentation: dsaRawData)
        XCTAssertEqual(dsaPrivateKey.publicKey.rawRepresentation,
                       restoredDsaKey.publicKey.rawRepresentation,
                       "ML-DSA-65 key should survive round-trip")
    }
    
 // MARK: - HPKE Integration Test
    
    func testHPKEIntegration() async throws {
        let provider = ApplePQCCryptoProvider()
        
 // 生成密钥对
        let keyPair = try await provider.generateKeyPair(for: .keyExchange)
        
 // 测试数据
        let plaintext = Data("Hello, Post-Quantum World!".utf8)
        let info = Data("SkyBridge HPKE Test".utf8)
        
 // 封装
        let sealedBox = try await provider.hpkeSeal(
            plaintext: plaintext,
            recipientPublicKey: keyPair.publicKey.bytes,
            info: info
        )
        
 // 解封装
        let decrypted = try await provider.hpkeOpen(
            sealedBox: sealedBox,
            privateKey: keyPair.privateKey.bytes,
            info: info
        )
        
        XCTAssertEqual(plaintext, decrypted,
                       "HPKE round-trip should preserve plaintext")
    }
    
 // MARK: - Property 9: HKDF info parameter differentiation
    
 /// **Feature: apple-pqc-implementation, Property 9: HKDF info parameter differentiation**
 /// **Validates: Requirements 3.5**
 ///
 /// *For any* shared secret and two different info parameters,
 /// HKDF derivation should produce different symmetric keys.
    func testProperty9_HKDFInfoParameterDifferentiation() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for _ in 0..<propertyTestIterations {
 // Generate a key pair
            let keyPair = try await provider.generateKeyPair(for: .keyExchange)
            
 // Generate random plaintext
            let plaintextSize = Int.random(in: 16...256)
            var plaintext = Data(count: plaintextSize)
            _ = plaintext.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, plaintextSize, $0.baseAddress!) }
            
 // Generate two different info parameters
            let info1Size = Int.random(in: 1...64)
            var info1 = Data(count: info1Size)
            _ = info1.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, info1Size, $0.baseAddress!) }
            
 // Ensure info2 is different from info1
            var info2 = Data(count: info1Size)
            repeat {
                _ = info2.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, info1Size, $0.baseAddress!) }
            } while info1 == info2
            
 // Seal with info1
            let sealedBox1 = try await provider.hpkeSeal(
                plaintext: plaintext,
                recipientPublicKey: keyPair.publicKey.bytes,
                info: info1
            )
            
 // Seal with info2 (same plaintext, same key, different info)
            let sealedBox2 = try await provider.hpkeSeal(
                plaintext: plaintext,
                recipientPublicKey: keyPair.publicKey.bytes,
                info: info2
            )
            
 // The ciphertexts should be different because:
 // 1. Different info -> different derived key
 // 2. Different nonce (randomly generated)
 // Note: We can't directly compare derived keys, but we can verify
 // that opening with wrong info fails
            
 // Try to open sealedBox1 with info2 - should fail or produce wrong plaintext
            do {
                let decrypted = try await provider.hpkeOpen(
                    sealedBox: sealedBox1,
                    privateKey: keyPair.privateKey.bytes,
                    info: info2  // Wrong info!
                )
 // If decryption succeeds, the plaintext should be different (corrupted)
 // This is unlikely to happen due to AES-GCM authentication
                XCTAssertNotEqual(
                    decrypted,
                    plaintext,
                    "Decryption with wrong info should not produce original plaintext"
                )
            } catch {
 // Expected: AES-GCM authentication should fail with wrong key
 // This is the correct behavior - different info produces different key
            }
            
 // Verify correct info works
            let decrypted1 = try await provider.hpkeOpen(
                sealedBox: sealedBox1,
                privateKey: keyPair.privateKey.bytes,
                info: info1  // Correct info
            )
            XCTAssertEqual(decrypted1, plaintext, "Decryption with correct info should work")
            
            let decrypted2 = try await provider.hpkeOpen(
                sealedBox: sealedBox2,
                privateKey: keyPair.privateKey.bytes,
                info: info2  // Correct info
            )
            XCTAssertEqual(decrypted2, plaintext, "Decryption with correct info should work")
        }
    }
    
 // MARK: - Property 10: Invalid input error handling
    
 /// **Feature: apple-pqc-implementation, Property 10: Invalid input error handling**
 /// **Validates: Requirements 1.5, 3.4, 6.1**
 ///
 /// *For any* invalid key data (wrong size or corrupted),
 /// cryptographic operations should throw a CryptoProviderError with descriptive context.
    func testProperty10_InvalidInputErrorHandling() async throws {
        let provider = ApplePQCCryptoProvider()
        
        for _ in 0..<propertyTestIterations {
 // Generate random invalid key sizes (not matching expected sizes)
            let invalidPublicKeySize = Int.random(in: 1...100)  // Too small for ML-KEM-768 (1184)
            var invalidPublicKey = Data(count: invalidPublicKeySize)
            _ = invalidPublicKey.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, invalidPublicKeySize, $0.baseAddress!) }
            
            let invalidPrivateKeySize = Int.random(in: 1...50)  // Too small for ML-KEM-768 (96)
            var invalidPrivateKey = Data(count: invalidPrivateKeySize)
            _ = invalidPrivateKey.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, invalidPrivateKeySize, $0.baseAddress!) }
            
 // Test hpkeSeal with invalid public key
            do {
                let plaintext = Data("test".utf8)
                let info = Data("info".utf8)
                _ = try await provider.hpkeSeal(
                    plaintext: plaintext,
                    recipientPublicKey: invalidPublicKey,
                    info: info
                )
                XCTFail("hpkeSeal should throw error for invalid public key")
            } catch let error as CryptoProviderError {
 // Verify error is descriptive
                switch error {
                case .invalidKeyLength(let expected, let actual, _, let usage):
                    XCTAssertEqual(expected, ApplePQCCryptoProvider.mlkem768PublicKeySize)
                    XCTAssertEqual(actual, invalidPublicKeySize)
                    XCTAssertEqual(usage, .keyExchange)
                default:
 // Other CryptoProviderError types are also acceptable
                    break
                }
            } catch {
                XCTFail("Expected CryptoProviderError, got \(type(of: error))")
            }
            
 // Test hpkeOpen with invalid private key
            do {
 // First create a valid sealed box
                let validKeyPair = try await provider.generateKeyPair(for: .keyExchange)
                let plaintext = Data("test".utf8)
                let info = Data("info".utf8)
                let sealedBox = try await provider.hpkeSeal(
                    plaintext: plaintext,
                    recipientPublicKey: validKeyPair.publicKey.bytes,
                    info: info
                )
                
 // Try to open with invalid private key
                _ = try await provider.hpkeOpen(
                    sealedBox: sealedBox,
                    privateKey: invalidPrivateKey,
                    info: info
                )
                XCTFail("hpkeOpen should throw error for invalid private key")
            } catch let error as CryptoProviderError {
 // Verify error is descriptive
                switch error {
                case .invalidKeyLength(let expected, let actual, _, let usage):
                    XCTAssertEqual(expected, ApplePQCCryptoProvider.mlkem768PrivateKeySize)
                    XCTAssertEqual(actual, invalidPrivateKeySize)
                    XCTAssertEqual(usage, .keyExchange)
                default:
 // Other CryptoProviderError types are also acceptable
                    break
                }
            } catch {
                XCTFail("Expected CryptoProviderError, got \(type(of: error))")
            }
            
 // Test sign with invalid private key
            let invalidSigningKeySize = Int.random(in: 1...30)  // Too small for ML-DSA-65 (64)
            var invalidSigningKey = Data(count: invalidSigningKeySize)
            _ = invalidSigningKey.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, invalidSigningKeySize, $0.baseAddress!) }
            
            do {
                let data = Data("test data".utf8)
                _ = try await provider.sign(data: data, using: .softwareKey(invalidSigningKey))
                XCTFail("sign should throw error for invalid private key")
            } catch let error as CryptoProviderError {
                switch error {
                case .invalidKeyLength(let expected, let actual, _, let usage):
                    XCTAssertEqual(expected, ApplePQCCryptoProvider.mldsa65PrivateKeySize)
                    XCTAssertEqual(actual, invalidSigningKeySize)
                    XCTAssertEqual(usage, .signing)
                default:
                    break
                }
            } catch {
                XCTFail("Expected CryptoProviderError, got \(type(of: error))")
            }
            
 // Test verify with invalid public key
            let invalidVerifyKeySize = Int.random(in: 1...100)  // Too small for ML-DSA-65 (1952)
            var invalidVerifyKey = Data(count: invalidVerifyKeySize)
            _ = invalidVerifyKey.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, invalidVerifyKeySize, $0.baseAddress!) }
            
            do {
                let data = Data("test data".utf8)
                let signature = Data(repeating: 0, count: 100)  // Dummy signature
                _ = try await provider.verify(data: data, signature: signature, publicKey: invalidVerifyKey)
                XCTFail("verify should throw error for invalid public key")
            } catch let error as CryptoProviderError {
                switch error {
                case .invalidKeyLength(let expected, let actual, _, let usage):
                    XCTAssertEqual(expected, ApplePQCCryptoProvider.mldsa65PublicKeySize)
                    XCTAssertEqual(actual, invalidVerifyKeySize)
                    XCTAssertEqual(usage, .signing)
                default:
                    break
                }
            } catch {
                XCTFail("Expected CryptoProviderError, got \(type(of: error))")
            }
        }
    }
    
 // MARK: - API Symbol Documentation
    
 /// 记录已确认的 API 符号名
    func testDocumentConfirmedAPISymbols() {
 // macOS 26 SDK 确认的 API 符号名：
 //
 // ML-KEM-768 (FIPS 203):
 // - 类型名: MLKEM768.PrivateKey, MLKEM768.PublicKey
 // - 公钥长度: 1184 bytes (rawRepresentation)
 // - 私钥长度: 96 bytes (integrityCheckedRepresentation - seed-based compact format)
 // - 密文长度: 1088 bytes
 // - 共享密钥: SymmetricKey (32 bytes)
 // - 封装: publicKey.encapsulate() throws -> (sharedSecret, encapsulated)
 // - 解封装: privateKey.decapsulate(_:) throws -> SymmetricKey
 //
 // ML-DSA-65 (FIPS 204):
 // - 类型名: MLDSA65.PrivateKey, MLDSA65.PublicKey
 // - 公钥长度: 1952 bytes (rawRepresentation)
 // - 私钥长度: 64 bytes (integrityCheckedRepresentation - seed-based compact format)
 // - 签名: privateKey.signature(for:) throws -> Data
 // - 验签: publicKey.isValidSignature(_:for:) -> Bool
 //
 // Note: Apple CryptoKit uses seed-based compact representation for private keys,
 // which is more storage-efficient than the FIPS expanded format.
    }
}

#else

/// 占位测试 - 当 HAS_APPLE_PQC_SDK 未定义时
/// 确保测试套件在旧 SDK 上仍能编译和运行
final class PQCProbeTests: XCTestCase {
    
    func testPQCSDKNotAvailable() {
 // HAS_APPLE_PQC_SDK 未定义，跳过 PQC 探针测试
 // 这是预期行为 - 在 macOS 26 SDK 可用前，此测试始终通过
    }
}

#endif
